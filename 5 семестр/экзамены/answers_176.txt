0. [Архитектура Windows] К исполнительной системе Windows не относится
	0.  (+) Служба сервера
	1.  (-) Диспетчер кэша
	2.  (-) Монитор безопасности
	3.  (-) Диспетчер электропитания
1. [Архитектура Windows] Ветвь HKEY_CURRENT_USER реестра хранит сведения о
	0.  (+) Настройках персональной оболочки пользователя, совершающего вход в операционную систему (меню «Пуск», рабочий стол и т. д.)
	1.  (-) Настройках Windows для всех пользователей
	2.  (-) Расширениях всех зарегистрированных в системе типов файлов и данные о COM-серверах, зарегистрированных на компьютере
	3.  (-) Состоянии устройств, установленных на компьютере
2. [Архитектура Windows] К ветвям реестра Windows-систем не относится
	0.  (+) HKEY_USER
	1.  (-) HKEY_CLASSES_ROOT
	2.  (-) HKEY_LOCAL_MACHINE
	3.  (-) HKEY_CURRENT_CONFIG
3. [Архитектура Windows] Для закрытия объектов ядра Windows применяют функцию
	0.  (+) CloseHandle
	1.  (-) Close
	2.  (-) FreeLibrary
	3.  (-) CloseKernelObject
4. [Архитектура Windows] Венгерская нотация — соглашение об именовании переменных, суть которого сводится к тому, что
	0.  (+) имена идентификаторов предваряются заранее оговорёнными префиксами, состоящими из одного или нескольких символов
	1.  (-) в именах идентификаторов опускаются гласные буквы
	2.  (-) имена идентификаторов завершаются заранее оговоренными суффиксами, состоящими из одного или нескольких символов
	3.  (-) имена идентификаторов всегда записываются, начиная с прописной буквы
5. [Архитектура Windows] К объектам ядра не относится
	0.  (+) Критические разделы
	1.  (-) Маркеры доступа
	2.  (-) Проекции файлов
	3.  (-) Процессы
6. [Архитектура Windows] Для описания дескриптора объекта в Windows API используется тип
	0.  (+) HANDLE
	1.  (-) BOOL
	2.  (-) DWORD
	3.  (-) LPSECURITY_ATTRIBUTES
7. [Архитектура Windows] К системным процессам Windows не относится
	0.  (+) Winword.exe
	1.  (-) Smss.exe
	2.  (-) Winlogon.exe
	3.  (-) Svchost.exe
8. [Архитектура Windows] Ядро ОС Windows находится в файле
	0.  (+) Ntoskrnl.exe
	1.  (-) Kernel32.dll
	2.  (-) Ntdll.dll
	3.  (-) Ntkrnlmp.exe
9. [Архитектура Windows] Большинство внутренних текстовых строк в Windows хранится в кодировке
	0.  (+) UTF16
	1.  (-) UTF8
	2.  (-) UTF32
	3.  (-) ANSI
10. [Архитектура Windows] Ветвь HKEY_LOCAL_MACHINE реестра хранит сведения о
	0.  (+) Операционной системе и оборудовании, сведения о загрузке Windows
	1.  (-) Расширениях всех зарегистрированных в системе файлов и данные о COM-серверах
	2.  (-) Профилях всех пользователей данного компьютера
	3.  (-) Профилях оборудования, использующегося в данном сеансе работы
11. [Архитектура Windows] Загружаемый модуль режима ядра, предоставляющий низкоуровневый интерфейс для аппаратной платформы, на которой выполняется Windows
	0.  (+) HAL
	1.  (-) DAL
	2.  (-) DDK
	3.  (-) VMS
12. [Архитектура Windows] К DLL подсистемы Windows не относится
	0.  (+) Psxdll.dll
	1.  (-) Kernel32.dll
	2.  (-) Advapi32.dll
	3.  (-) User32.dll
13. [Динамические библиотеки] При использовании статической библиотеки
	0.  (+) Программа компилируется один раз и может запускаться на любом компьютере без дополнительных библиотек
	1.  (-) Программа будет запускаться, если в системе присутствует эта статическая библиотека
	2.  (-) Программа будет запускаться только при использовании виртуальной машины
	3.  (-) Статические библиотеки используются только интерпретируемыми программами, т.е. программа будет запускаться на любом компьютере
14. [Динамические библиотеки] Функция входа в DLL — это функция
	0.  (+) DllMain
	1.  (-) MainDll
	2.  (-) dllMain
	3.  (-) Main
15. [Динамические библиотеки] Для указания экспортируемых из DLL функций применяют конструкцию
	0.  (+) __declspec( dllexport )
	1.  (-) declspec( dllexport )
	2.  (-) __declspec( export )
	3.  (-) declspec( export )
16. [Динамические библиотеки] При загрузке DLL c явной компоновкой
	0.  (+) Необходимо настроить указатель на функцию, включенную в DLL, для доступа к ней
	1.  (-) Необходимо наличие lib-файла
	2.  (-) Обращение к функциям DLL выполняется так же, как и к локальным функциям
	3.  (-) Загрузка DLL осуществляется одновременно с загрузкой исполняемого файла, который ее использует
17. [Динамические библиотеки] При отключении DLL от адресного пространства процесса вызывается ее функция DllMain со значением параметра fdwReason равным
	0.  (+) DLL_PROCESS_DETACH
	1.  (-) DLL_PROCESS_ATTACH
	2.  (-) DLL_THREAD_DETACH
	3.  (-) DLL_THREADS_DETACH
18. [Динамические библиотеки] Для указания импортируемых из DLL функций применяют конструкцию
	0.  (+) __declspec( dllimport )
	1.  (-) declspec( dllimport )
	2.  (-) __declspec( import )
	3.  (-) declspec( import )
19. [Динамические библиотеки] Динамическая библиотека содержит
	0.  (+) Машинный код
	1.  (-) Байт-код
	2.  (-) Гибридный код
	3.  (-) Обычный код программы который подгружается динамически при необходимости
20. [Динамические библиотеки] Отличительный признак динамической библиотеки
	0.  (+) Одна копия может использоваться несколькими процессами
	1.  (-) Динамически вставляется в программу на этапе компоновки
	2.  (-) Содержит байт-код для виртуальной машины
	3.  (-) Одна библиотека может использоваться только одним процессом
21. [Динамические библиотеки] Расширение динамических библиотек в Windows
	0.  (+) dll
	1.  (-) so
	2.  (-) lib
	3.  (-) a
22. [Динамические библиотеки] Для загрузки DLL-библиотеки в память не применяют функцию
	0.  (+) GetProcAddress
	1.  (-) LoadLibrary
	2.  (-) LoadLibraryEx
	3.  (-) GetModuleHandle
23. [Динамические библиотеки] Расширение статических библиотек в Windows
	0.  (+) lib
	1.  (-) dll
	2.  (-) obj
	3.  (-) stat
24. [Динамические библиотеки] Изменение динамической библиотеки, влияет на программы которые ее используют?
	0.  (+) Влияет, на все работающие программы
	1.  (-) Изменит поведение всех програм, которые компилировались после изменения библиотеки
	2.  (-) Изменит только поведение программ на этапе компоновки которых был сгенерирован байт-код
	3.  (-) Никак не влияет
25. [Динамические библиотеки] Код статической библиотеки
	0.  (+) Включается в исполняемый файл
	1.  (-) Включается в исполняемый файл при необходимости
	2.  (-) Включается только ссылка на библиотеку
	3.  (-) Вообще не включается в исполняемый файл
26. [Динамические библиотеки] При создании нового потока в процессе, система для всех спроецированных в адресное пространство DLL вызывает функцию DllMain с параметром fdwReason равным
	0.  (+) DLL_THREAD_ATTACH
	1.  (-) DLL_PROCESS_ATTACH
	2.  (-) DLL_PROCESSES_ATTACH
	3.  (-) DLL_THREADS_ATTACH
27. [Динамические библиотеки] При загрузке DLL c неявной компоновкой
	0.  (+) Необходимо наличие lib-файла
	1.  (-) Необходимо настроить указатель на функцию, включенную в DLL, для доступа к ней
	2.  (-) Необходимо явно загрузить библиотеку
	3.  (-) Необходимо явно выгрузить библиотеку
28. [Динамические библиотеки] При нормальном завершении потока в процессе, система для всех спроецированных в адресное пространство DLL вызывает функцию DllMain с параметром fdwReason равным
	0.  (+) DLL_THREAD_DETACH
	1.  (-) DLL_THREAD_ATTACH
	2.  (-) DLL_PROCESS_DETACH
	3.  (-) DLL_THREADS_DETACH
29. [Динамические библиотеки] При проецировании DLL в адресное пространство процесса первый раз система вызывает DllMain со значением параметра fdwReason равным
	0.  (+) DLL_PROCESS_ATTACH
	1.  (-) DLL_PROCESS_DETACH
	2.  (-) DLL_THREADS_ATTACH
	3.  (-) DLL_THREAD_DETACH
30. [Динамические библиотеки] Процесс может использовать функции динамической библиотеки
	0.  (+) Если она загружена в память
	1.  (-) Если она загружена в память и ее функции не использует другой процесс
	2.  (-) Если она была включена в его код на этапе компоновки
	3.  (-) Непосредственно, без загрузки
31. [Динамические библиотеки] Расширение динамических библиотек в Linux
	0.  (+) so
	1.  (-) dll
	2.  (-) lib
	3.  (-) dlib
32. [Динамические библиотеки] Расширение статических библиотек в Linux
	0.  (+) a
	1.  (-) lib
	2.  (-) so
	3.  (-) dll
33. [Драйверы] Фильтрующие драйверы нужны для
	0.  (+) Исправления ошибок в существующих драйверах и их расширения
	1.  (-) Для управления устройствами конкретного типа
	2.  (-) Для осуществления взаимодействия между устройствами
	3.  (-) Для отслеживания устройств, подключаемых к системе
34. [Драйверы] DPC-точка входа драйвера нужна для
	0.  (+) Завершения работы, которая должна быть сделана в результате появления прерывания
	1.  (-) Обработки аппаратных прерываний от нижележащих устройств
	2.  (-) Вызова кода, когда истекает время запрошенного таймера
	3.  (-) Выполнения некоторых действий при выгрузке драйвера
35. [Драйверы] DriverEntry — это
	0.  (+) Процедура инициализации Windows-драйвера
	1.  (-) Процедура добавления устройства
	2.  (-) Процедура начала ввода-вывода
	3.  (-) Процедура обработки прерываний
36. [Драйверы] DriverEntry вызывается на IRQL равном
	0.  (+) PASSIVE_LEVEL
	1.  (-) APC_LEVEL
	2.  (-) DISPATCH_LEVEL
	3.  (-) на одном из DIRQL
37. [Драйверы] WDM — это
	0.  (+) Windows driver model
	1.  (-) Wavelength Division Multiplexing
	2.  (-) WINgs Display Manager
	3.  (-) Windows Display Monitor
38. [Драйверы] Драйвер NT располагается в файле с расширением
	0.  (+) sys
	1.  (-) so
	2.  (-) drv
	3.  (-) dll
39. [Драйверы] После удаления последнего объекта устройства и отсутствии ссылок на драйвер диспетчер ввода-вывода производит
	0.  (+) выгрузку этого драйвера
	1.  (-) повторную инициализацию этого драйвера
	2.  (-) замену этого драйвера
	3.  (-) удаление этого драйвера
40. [Драйверы] Какая процедура драйвера выполняет основную часть обработки прерывания, оставшейся после вызова ISR-процедуры
	0.  (+) DPC-процедура
	1.  (-) Процедура завершения ввода-вывода
	2.  (-) Процедура отмены ввода вывода
	3.  (-) Процедура обработки прерываний
41. [Драйверы] Драйверы, управляющие устройствами конкретного типа
	0.  (+) Функциональные драйверы
	1.  (-) Драйверы шины
	2.  (-) Фильтрующие драйверы
	3.  (-) Драйверы файловой системы
42. [Драйверы] ISR-точка входа драйвера нужна для
	0.  (+) Обработки прерываний
	1.  (-) Завершения ввода-вывода
	2.  (-) Выгрузки драйвера
	3.  (-) Инициализации драйвера
43. [Драйверы] С какой компонентой исполнительной системы Windows чаще всего взаимодействует драйвер
	0.  (+) Диспетчер ввода-вывода
	1.  (-) Монитор безопасности
	2.  (-) Диспетчер кэша
	3.  (-) Диспетчер процессов
44. [Драйверы] Драйверы PnP должны реализовывать эту процедуру
	0.  (+) процедура добавления устройства
	1.  (-) Процедура выгрузки
	2.  (-) процедура регистрации ошибок
	3.  (-) процедура отмены ввода -вывода
45. [Лексический анализ] Cтруктурная единица языка, которая состоит из элементарных символов языка это
	0.  (+) лексема
	1.  (-) токен
	2.  (-) строка
	3.  (-) слово
46. [Лексический анализ] Распознавание и выделение лексем из входной последовательности символов производится
	0.  (+) Лексическим анализатором
	1.  (-) Компилятором
	2.  (-) Интерпретатором
	3.  (-) Вторичным загрузчиком
47. [Лексический анализ] Лексический анализ
	0.  (+) является одним из первых этапов трансляции
	1.  (-) на этапе трансляции идет до обработки препроцессором
	2.  (-) при трансляции следует сразу же после синтаксического анализа
	3.  (-) при трансляции следует сразу же после семантического анализа
48. [Лексический анализ] Лексический анализ на лету – это
	0.  (+) функция тестового редактора в составе программирования
	1.  (-) первый этап лексического анализа
	2.  (-) последний этап лексического анализа
	3.  (-) функция текстового редактора заключающаяся в поиске и выделении лексем непосредственно после создания программы разработчиком
49. [Лексический анализ] Причинами, по которым в состав практически всех компиляторов включают лексический анализ являются
	0.  (+) все перечисленные варианты
	1.  (-) необходимость сокращать объем информации, обрабатываемой на этапе синтаксического разбора
	2.  (-) необходимость отделять синтаксический анализатор, сложный по конструкции, от работы непосредственно с текстом исходной программы
	3.  (-) возможность снизить трудоемкость разработки программ за счет обработки текста исходной программы, параллельно с его подготовкой пользователем
50. [Лексический анализ] В ЯП Pascal begin является
	0.  (+) ключевым словом
	1.  (-) идентификатором
	2.  (-) знаком арифметической операции
	3.  (-) разделителем
51. [Лексический анализ] Функции, выполняемые лексическим анализатором и тип лексем, которые он должен выделять определяются
	0.  (+) разработчиком компилятора
	1.  (-) формой Бэкуса-Наура
	2.  (-) второым классом грамматик Хомского
	3.  (-) только перечнем библиотечных функций
52. [Лексический анализ] Определение границ лексем — это
	0.  (+) выделение тех строк в общем потоке входных символов, для которых надо выполнять распознавание
	1.  (-) разбиение потока входных символов на блоки фиксированного размера
	2.  (-) задание соответствие между некоторой частью входных символов и смысловым значением соответствующей лексемы
	3.  (-) разбиение байтового потока на блоки фиксированного размера
53. [Лексический анализ] Таблица лексем содержит
	0.  (+) весь текст исходной программы, обработанный лексическим анализатором
	1.  (-) только ключевые слова исходной программы обработанный лексическим анализатором
	2.  (-) текст исходной программы обработанный лексическим анализатором
	3.  (-) таблицу идентификаторов
54. [Лексический анализ] Если измениться кодировка исходной программы, то это повлияет
	0.  (+) только на лексический анализатор
	1.  (-) на лексический и синтаксический анализаторы
	2.  (-) на синтаксический и семантический анализаторы
	3.  (-) на генератор объектного кода
55. [Лексический анализ] Причиной, по которой в состав практически всех компиляторов включают лексический анализ, является
	0.  (+) все перечисленные варианты
	1.  (-) возможность снизить трудоемкость разработки программ за счет обработки текста исходной программы, параллельно с его подготовкой пользователем
	2.  (-) необходимость отделять синтаксический анализатор, сложный по конструкции, от работы непосредственно с текстом исходной программы
	3.  (-) необходимость сокращать объем информации, обрабатываемой на этапе синтаксического разбора
56. [Лексический анализ] К типам лексем ЯП не относится
	0.  (+) альфа-лексемы
	1.  (-) разделители
	2.  (-) ключевые слова
	3.  (-) идентификаторы
57. [Лексический анализ] Теоретической моделью, используемой при построении лексического анализатора, является
	0.  (+) Конечный автомат
	1.  (-) Машина Тьюринга
	2.  (-) Клеточный автомат
	3.  (-) Линейный автомат
58. [Лексический анализ] В ЯП Pascal else является
	0.  (+) ключевым словом
	1.  (-) идентификатором
	2.  (-) знаком арифметической операции
	3.  (-) разделителем
59. [Оконные приложения] Прием сообщений в главном цикле обработки сообщений в программах ОС Windows осуществляет функция
	0.  (+) GetMessage
	1.  (-) TranslateMessage
	2.  (-) DispatchMessage
	3.  (-) RecordMessage
60. [Оконные приложения] Для инициации механизма перерисовки окна в Windows-приложениях нужно вызвать функцию
	0.  (+) InvalidateRect
	1.  (-) UpdateWindow
	2.  (-) BeginPaint
	3.  (-) EndPaint
61. [Оконные приложения] Назначение оконной функции — это
	0.  (+) Обработка событий для этого окна
	1.  (-) Конструирование и инстанцирование класса окна
	2.  (-) Прорисовка окна
	3.  (-) Правильного варианта нет
62. [Оконные приложения] Точкой входа в Windows-приложение является функция
	0.  (+) WinMain
	1.  (-) main
	2.  (-) winMain
	3.  (-) Main
63. [Оконные приложения] Выберите неверное утверждение об асинхронных сообщениях в ОС Windows
	0.  (+) Возврат к вызывающему коду происходит только после окончания обработки сообщения оконной процедурой
	1.  (-) Сообщения ставятся в очередь асинхронных сообщений вызовом функции PostMessage
	2.  (-) Возврат к вызывающему коду происходит сразу после того, как сообщение поставлено в очередь
	3.  (-) Окно может не получить асинхронное сообщение
64. [Оконные приложения] Какая структура данных используется для хранения оконных сообщений?
	0.  (+) Очередь
	1.  (-) Стек
	2.  (-) Список
	3.  (-) Массив
65. [Оконные приложения] Выберите неверное утверждение о синхронных сообщениях в ОС Windows
	0.  (+) Сообщения ставятся в очередь синхронных сообщений вызовом функции PostQuitMessage
	1.  (-) Возврат к вызывающему коду происходит только после окончания обработки сообщения оконной процедурой
	2.  (-) Синхронное сообщение можно передать другому потоку, включив в его очередь сообщений и установив флаг QS_SENDMESSAGE
	3.  (-) Синхронное сообщение можно отправить вызовом функции SendMessage
66. [Оконные приложения] К стандартным видам ресурсов Windows-программ не относится
	0.  (+) Bitmap Table
	1.  (-) Menu
	2.  (-) Icon
	3.  (-) Font
67. [Оконные приложения] К типам оконных сообщений Windows не относится
	0.  (+) WM_CLICK
	1.  (-) WM_DESTROY
	2.  (-) WM_MOVE
	3.  (-) WM_CLOSE
68. [Оконные приложения] Загрузка ресурса из внешнего исполняемого файла для Windows-приложений выполняется с помощью функции
	0.  (+) LoadResource
	1.  (-) LoadLibrary
	2.  (-) LoadModule
	3.  (-) FindResource
69. [Оптимизация кода] Линейный участок программы
	0.  (+) выполняемая по порядку последовательность операций имеющая один вход и один выход
	1.  (-) выполняемая по приоритету последовательность операций, имеющая один вход и один выход
	2.  (-) выполняемая по порядку последовательность операций, имеющая один вход и множество выходов
	3.  (-) выполняемая по порядку последовательность операций, имеющая множество входов и один выход
70. [Оптимизация кода] Для линейных участков не могут выполняться следующие виды оптимизации
	0.  (+) развертка объектного кода
	1.  (-) удаление бесполезных присваиваний
	2.  (-) исключение лишних вычислений
	3.  (-) перестановка операций
71. [Оптимизация кода] Что является критериями оптимизации кода
	0.  (+) размер и скорость
	1.  (-) только скорость
	2.  (-) размер и сложность
	3.  (-) скорость и сложность
72. [Оптимизация кода] обработка, связанная с переупорядочиванием и изменением операций в компилируемой программе с целью получения более эффективной результирующей объектной программы
	0.  (+) Оптимизация
	1.  (-) Генерация промежуточного кода
	2.  (-) Рефакторинг
	3.  (-) Семантический анализ
73. [Оптимизация кода] К приемам оптимизации линейных участков программы не относится
	0.  (+) вынесение инвариантных вычислений из циклов
	1.  (-) удаление бесполезных присваиваний
	2.  (-) исключение избыточных вычислений (лишних операций)
	3.  (-) арифметические преобразования
74. [Оптимизация кода] К приемам оптимизации циклов не относится
	0.  (+) свертка операций объектного кода
	1.  (-) вынесение инвариантных вычислений из циклов
	2.  (-) замена операций с индуктивными переменными
	3.  (-) слияние и развертывание циклов
75. [Оптимизация кода] К приемам оптимизации не относится
	0.  (+) извлечение метода
	1.  (-) подстановка кода функции в вызывающий объектный код
	2.  (-) передача параметров через регистры процессора
	3.  (-) слияние и развертывание циклов
76. [Оптимизация кода] Особенностью оптимизации как этапа трансляции является
	0.  (+) ее необязательность
	1.  (-) ее обязательность
	2.  (-) потенциальная невозможность
	3.  (-) правильного варианта нет
77. [Практика (Linux)] Сравните файлы ls и ln, находящиеся в каталоге /bin, используя абсолютные имена файлов
	0.  (+) cmp /bin/ls /bin/ln
	1.  (-) cmp ./bin/ls ./bin/ln
	2.  (-) cmp ../bin/ls ../bin/ln
	3.  (-) cmp ~/bin/ls ~/bin/ln
78. [Практика (Linux)] Вы находитесь в каталоге ~/. Просмотрите первые 10 строк файла /etc/group, используя относительное имя файла
	0.  (+) head -10 ../../etc/group
	1.  (-) head -10 ~/etc/group
	2.  (-) head -10 ././etc/./group
	3.  (-) head -10 ./././etc/group
79. [Практика (Linux)] Вы находитесь в каталоге /usr/bin. Просмотрите первые 10 строк файла /home/user/mytxt, используя относительное имя файла
	0.  (+) head -10 ../../home/user/mytxt
	1.  (-) head -10 /home/user/mytxt
	2.  (-) head -10 ././././home/user/mytxt
	3.  (-) head -10 ~/../home/user/mytxt
80. [Практика (Linux)] Вы находитесь в каталоге /usr/bin. Просмотрите первые 10 строк файла ~/mytxt, используя абсолютное имя файла
	0.  (+) head -10 /home/user/mytxt
	1.  (-) ls -10 /home/user/mytxt
	2.  (-) tail -10 /home/user/mytxt
	3.  (-) more -10 /home/user/mytxt
81. [Практика (Linux)] Вы находитесь в каталоге ~. Где вы окажетесь после применения команды cd ../../../../../../../..
	0.  (+) /
	1.  (-) ../../..
	2.  (-) ../../../../../../../..
	3.  (-) ./././././././.
82. [Практика (Linux)] Вы находитесь в каталоге ~. Где вы окажетесь после применения команды cd ../././././././vasia/./.././brother
	0.  (+) /home/brother
	1.  (-) /home/vasia/brother
	2.  (-) /home/vasia
	3.  (-) /brother
83. [Практика (Linux)] Вы находитесь в каталоге ~. Где вы окажетесь после применения команды cd 1/2/3/././4/././..
	0.  (+) /home/user/1/2/3
	1.  (-) /home/1/2/3
	2.  (-) /1/2/3
	3.  (-) /home/2/3
84. [Практика (Linux)] Вы находитесь в каталоге /usr/local/bin. Где вы окажетесь после применения команды cd /../../../../etc/././..
	0.  (+) /
	1.  (-) /etc
	2.  (-) /etc/./.
	3.  (-) /..
85. [Практика (Linux)] Вы находитесь в каталоге /usr/local/bin. Где вы окажетесь после применения команды cd /../var/./././
	0.  (+) /var
	1.  (-) /usr/local/var
	2.  (-) /usr/local/bin/var
	3.  (-) /usr/var
86. [Практика (Linux)] Поменяйте владельца и группу файла ~/mytxt на root
	0.  (+) chown root:root ~/mytxt
	1.  (-) chmod root ~/mytxt
	2.  (-) chgrp root ~/mytxt
	3.  (-) chown root  ~/mytxt
87. [Практика (Linux)] Установите, используя символы прав доступа следующие права на файл ~/mytxt: для себя все права, для группы и остальных — никаких
	0.  (+) chmod u=rwx,go=  ~/mytxt
	1.  (-) chmod ugo=rwx  ~/mytxt
	2.  (-) chmod u=r,g=wx,o=  ~/mytxt
	3.  (-) chmod u=,go=rwx  ~/mytxt
88. [Практика (Linux)] Установите при помощи восьмеричных масок следующие права на файл ~/mytxt: для себя все права, для группы и остальных — никаких
	0.  (+) chmod 700 ~/mytxt
	1.  (-) chmod 500 ~/mytxt
	2.  (-) chmod 300 ~/mytxt
	3.  (-) chmod 100 ~/mytxt
89. [Практика (Linux)] Установите при помощи восьмеричных масок следующие права на файл ~/mytxt: для себя исполнение и запись, для группы никаких, для остальных чтение
	0.  (+) chmod 501 ~/mytxt
	1.  (-) chmod 701 ~/mytxt
	2.  (-) chmod 507 ~/mytxt
	3.  (-) chmod 505 ~/mytxt
90. [Практика (Linux)] Просмотрите руководство по команде head
	0.  (+) man head
	1.  (-) ruk head
	2.  (-) ls head
	3.  (-) cp head
91. [Практика (Linux)] Создайте жесткую ссылку для файла /home/user1/mytxt.txt с тем же именем, поместив ее в каталог /home/user1/work
	0.  (+) ln /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	1.  (-) ln -s /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	2.  (-) ln -h /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	3.  (-) ls /home/user1/mytxt.txt /home/user1/work/mytxt.txt
92. [Практика (Linux)] Создайте символьную ссылку для файла /home/user1/mytxt.txt с тем же именем, поместив ее в каталог /home/user1/work
	0.  (+) ln -s /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	1.  (-) ln -s mytxt.txt work/mytxt.txt
	2.  (-) link /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	3.  (-) ls /home/user1/mytxt.txt /home/user1/work/mytxt.txt
93. [Синтаксический анализ] На этапе трансляции синтаксический анализ
	0.  (+) следует сразу после лексического анализа
	1.  (-) следует после семантического анализа
	2.  (-) выполняется последним
	3.  (-) выполняется первым
94. [Синтаксический анализ] Синтаксический анализатор – это
	0.  (+) часть компилятора которая отвечает за выявление и проверку синтаксических конструкций входного языка
	1.  (-) слабоформализуемая часть трансляции, состоящая в жесткой проверке контекстных зависимостей
	2.  (-) часть компилятора, которая создает синтаксические конструкций входного языка
	3.  (-) часть компилятора, которая читает исходную программу и выделяет в ее тексте лексемы входного языка
95. [Синтаксический анализ] Что подается на вход синтаксического анализатора?
	0.  (+) сформированная ЛА таблица лексем
	1.  (-) таблица идентификаторов, сформированная ЛА
	2.  (-) все перечисленные варианты
	3.  (-) только код генерируемой программы
96. [Синтаксический анализ] Деревом вывода грамматики G(T,N,P,S) называется дерево (граф), которое соответствует некоторой цепочке вывода и удовлетворяет следующим условиям:
	0.  (+) все перечисленное
	1.  (-) каждая вершина обозначается символом грамматики V in (T \cup N \cup {e})
	2.  (-) корнем дерева является вершина, обозначенная аксиомой S
	3.  (-) листьями являются вершины, обозначенные символом t in (T \cup {e})
97. [Синтаксический анализ] На основе какого синтаксического анализатора легче организовать процесс порождения цепочек результирующего языка?
	0.  (+) все варианты являются верными
	1.  (-) на основе левостороннего
	2.  (-) на основе нисходящего
	3.  (-) на основе анализатора, просматривающего входную цепочку символов слева направо
98. [Синтаксический анализ] В основе нисходящего синтаксического анализа
	0.  (+) Лежит левосторонний разбор
	1.  (-) Лежит правосторонний разбор
	2.  (-) Лежит параллельный разбор
	3.  (-) Лежит праворекурсивный разбор
99. [Синтаксический анализ] МПА при построении синтаксического анализатора - это
	0.  (+) автомат с магазинной памятью
	1.  (-) межпроцессорный автомат
	2.  (-) мультипроцессорный автомат
	3.  (-) автомат на базе МП символики
100. [Синтаксический анализ] Одним из самых простых методов синтаксического анализа является
	0.  (+) метод рекурсивного спуска
	1.  (-) метод рекурсивного подъема
	2.  (-) метод градиентного спуска
	3.  (-) метод наискорейшего подъема
101. [Синтаксический анализ] Характерной особенностью автомата с магазинной памятью является
	0.  (+) наличие дополнительной памяти в виде стека
	1.  (-) наличие дополнительной памяти в виде связного списка
	2.  (-) ограниченный объем ленты
	3.  (-) наличие управляющего устройства
102. [Синтаксический анализ] Метод рекурсивного спуска применим к
	0.  (+) подклассу КС-грамматик
	1.  (-) подклассу КЗ-грамматик
	2.  (-) подклассу грамматик типа 0
	3.  (-) подклассу Р-грамматик
103. [Синтаксический анализ] Синтаксис языков программирования описывают с помощью
	0.  (+) контекстно-свободных грамматик
	1.  (-) контекстно-зависимых грамматик
	2.  (-) грамматик типа 0
	3.  (-) регулярных грамматик
104. [Синтаксический анализ] Детерминированный МПА
	0.  (+) может быть определен как семерка вида: P = (Q, Σ, Γ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет не более одного элемента
	1.  (-) может быть определен как семерка вида: P = (Q, Σ, Γ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет более одного элемента
	2.  (-) может быть определен как шестерка вида: P = (Q, Σ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет не более одного элемента
	3.  (-) может быть определен как пятерка вида: P = (Q, Σ, δ, q0, Z0), для функции переходов δ которой δ(q, a, X) имеет не более одного элемента
105. [Синтаксический анализ] Недетерминированный МПА
	0.  (+) может быть определен как семерка вида: P = (Q, Σ, Γ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет более одного элемента
	1.  (-) может быть определен как семерка вида: P = (Q, Σ, Γ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет не более одного элемента
	2.  (-) может быть определен как шестерка вида: P = (Q, Σ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет более одного элемента
	3.  (-) может быть определен как пятерка вида: P = (Q, Σ, δ, q0, F), для функции переходов δ которой δ(q, a, X) имеет более одного элемента
106. [Способы определения языка] Форма Бекуса-Наура используется для
	0.  (+) описания нерегулярных формальных грамматик
	1.  (-) описания регулярных формальных грамматик
	2.  (-) описания контекстно-свободных формальных грамматик
	3.  (-) описания контекстно-зависимых формальных грамматик
107. [Способы определения языка] Возможность описания бесконечного множества цепочек языка с помощью конечного набора правил в форме Бекуса-Наура
	0.  (+) описания контекстно-свободных формальных грамматик
	1.  (-) описания регулярных формальных грамматик
	2.  (-) описания нерегулярных формальных грамматик
	3.  (-) описания контекстно-зависимых формальных грамматик
108. [Способы определения языка] Распознаватель – это
	0.  (+) специальный автомат который позволяет определить принадлежность цепочки символов некоторому языку
	1.  (-) специализированная программа, предназначенная для расшифровки текста
	2.  (-) последовательность ячеек, каждая из которых содержит один символ некоторого конечного входного алфавита
	3.  (-) специализированные устройства, которые вычленяют текст из графических файлов
109. [Способы определения языка] По типу считывающего устройства распознаватели разделяются на
	0.  (+) односторониие и двусторонние
	1.  (-) детерминированные, недетерминированные
	2.  (-) без внешней памяти, с ограниченной внешней памятью, с неограниченной внешней памятью
	3.  (-) одноканальные, многоканальные
110. [Способы определения языка] Выберите действие, которое не выполняется распознавателем
	0.  (+) Удаление данных с ленты
	1.  (-) Чтение очередного символа с ленты
	2.  (-) Анализ входного символа памяти и текущего состояния
	3.  (-) Перемещение при необходимости входной головки
111. [Способы определения языка] К структурным компонентам распознавателя не относится
	0.  (+) Конфигурация
	1.  (-) Входная лента
	2.  (-) Входная головка
	3.  (-) Управляющее устройство
112. [Способы определения языка] Управляющее устройство называется детерминированным, если
	0.  (+) Для каждой конфигурации распознавателя существует не более одного возможного следующего шага
	1.  (-) Для каждой конфигурации распознавателя существует более одного возможного следующего шага
	2.  (-) Для каждой конфигурации распознавателя существует ровно два возможных следующих шага
	3.  (-) Для любой конфигурации распознавателя не существует возможных следующих шагов
113. [Способы определения языка] Конфигурация распознавателя называется начальной, если
	0.  (+) управляющее устройство находится в заданном начальном состоянии, входная головка обозревает самый левый символ на входной ленте и вспомогательная память имеет заранее установленное начальное состояние.
	1.  (-) управляющее устройство находится в заданном начальном состоянии, входная головка сошла с правого конца входной ленты.
	2.  (-) управляющее устройство находится в заданном начальном состоянии.
	3.  (-) управляющее устройство находится в заданном начальном состоянии, входная головка сошла с правого конца входной ленты и вспомогательная память имеет заранее установленное начальное состояние.
114. [Способы определения языка] Формальная грамматика определяется с помощью
	0.  (+) множества нетерминальных и терминальных символов, правил вывода и начального символа
	1.  (-) множества терминальных символов, правил вывода и начального символа
	2.  (-) множества нетерминальных символов, правил вывода и начального символа
	3.  (-) правил вывода и начального символа
115. [Способы определения языка] К метасимволам языка РБНФ не относится
	0.  (+) «//»
	1.  (-) «[» и «]»
	2.  (-) «{» и «}»
	3.  (-) «|»
116. [Способы определения языка] Конфигурация распознавателя называется конечной, если
	0.  (-) управляющее устройство находится в заданном состоянии, входная головка обозревает самый левый символ на входной ленте и вспомогательная память имеет заранее установленное состояние.
	1.  (+) управляющее устройство находится в заданном конечном состоянии, входная головка обозревает самый правый символ входной ленты и вспомогательная память имеет заранее установленное конечное состояние.
	2.  (-) управляющее устройство находится в заданном конечном состоянии, входная головка обозревает самый левый символ ленты.
	3.  (-) управляющее устройство находится в заданном конечном состоянии.
117. [Способы определения языка] Язык, определяемый распознавателем, это
	0.  (+) множество всех цепочек, которые допускает распознаватель
	1. [DISABLED] (-) множество цепочек, состоящих из нулей и единиц
	2. [DISABLED] (-) множество цепочек, состоящих из букв латинского алфавита
	3. [DISABLED] (-) правильных вариантов нет
	4.  (-) множество всех правил, которые реализуются распознавателем
	5.  (-) множество всех нетерминалов, которые допускаются распознавателем
	6.  (-) множество всех символов, которые допускает распознаватель
118. [Способы определения языка] Форма Бэкуса-Наура используется для
	0.  (+) описания контекстно-свободных формальных грамматик
	1.  (-) описания грамматик с фразовой структурой
	2.  (-) описания регулярных формальных грамматик
	3.  (-) описания контекстно-зависимых формальных грамматик
119. [Трансляция программ] Ассемблер - это частный случай
	0.  (+) компилятора
	1.  (-) интерпретатора
	2.  (-) компоновщика
	3.  (-) отладчика
120. [Трансляция программ] Интерпретатор это
	0.  (+) программа, которая воспринимает входную программу на исходном языке и выполняет ее.
	1.  (-) программа, которая переводит входную программу на исходном языке в эквивалентную ей выходную программу на результирующем языке.
	2.  (-) это транслятор, который осуществляет перевод исходной программы в эквивалентную ей объектную программу на языке машинных команд или языке ассемблера.
	3.  (-) программа, которая воспринимает входную программу на исходном языке и передает сформированный машинный код компилятору.
121. [Трансляция программ] Что такое препроцессор
	0.  (+) транслятор с одного языка программирования в другой без создания исполняемого файла или выполнения программы
	1.  (-) первый этап трансляции
	2.  (-) это транслятор для интерпретируемых языков программирования
	3.  (-) инструкция, которая подается в материанскую плату для инициализации работы процессора
122. [Трансляция программ] Какое утверждение является верным (вопрос об отношении между компилятором, транслятором и интерпретатором)
	0.  (+) Компилятор - частный случай транслятора
	1.  (-) Транслятор - частный случай компилятора
	2.  (-) Интерпретатор - частный случай компилятора
	3.  (-) Компилятор - частный случай интерпретатора
123. [Трансляция программ] Какое утверждение является неверным (вопрос об отношении между компилятором, транслятором и интерпретатором)
	0.  (+) Интерпретатор - частный случай компилятора
	1.  (-) Компилятор - частный случай транслятора
	2.  (-) Асемблер - частный случай транслятора
	3.  (-) Интерпретатор - частный случай транслятора
124. [Трансляция программ] На последнем этапе трансляции исходный код превращается в
	0.  (+) исполняемый файл
	1.  (-) объектный файл
	2.  (-) байт-код
	3.  (-) код на языке ассемблера
125. [Трансляция программ] Исходный код это
	0.  (+) язык, на котором представлена входная программа
	1.  (-) результат последнего этапа трансляции
	2.  (-) последовательность байт-кода из которого компилируется машинный код
	3.  (-) язык описания алгоритмов использующий ключевые слова языков программирования, но опускающий подробности и специфический синтаксис
126. [Трансляция программ] Для того, чтобы выполнить программу, необходимо
	0.  (+) Разместить ее в памяти компьютера.
	1.  (-) Записать ее в MBR.
	2.  (-) Сгенерировать объектный файл.
	3.  (-) Перевести программу на язык ассемблера.
127. [Трансляция программ] Что из перечисленного не является этапом трансляции программы
	0.  (+) Морфологический анализ
	1.  (-) Семантический анализ
	2.  (-) Синтаксический анализ
	3.  (-) Лексический анализ
128. [Трансляция программ] Компиляция это
	0.  (+) трансляция исходного кода в машинный
	1.  (-) трансляция ассемблерного кода в машинный
	2.  (-) трансляция исходного кода в ассемблер
	3.  (-) трансляция машинного кода в ассемблерный
129. [Трансляция программ] Программа, позволяющая управлять процессом выполнения программы и обнаруживать в ней ошибки
	0.  (+) отладчик
	1.  (-) компоновщик
	2.  (-) компилятор
	3.  (-) загрузчик
130. [Трансляция программ] gcc это
	0.  (+) компилятор
	1.  (-) сборщик мусора
	2.  (-) вторичный загрузчик
	3.  (-) транслятор ассемблера для linux
131. [Трансляция программ] Программа, которая собирает исполняемый файл из нескольких объектных модулей, называется
	0.  (+) Компоновщик
	1.  (-) Компилятор
	2.  (-) Препроцессор
	3.  (-) Динамический компилятор
132. [Трансляция программ] К общим синтаксическим критериям не относится
	0.  (+) Малое потребление ресурсов
	1.  (-) Легкость чтения
	2.  (-) Легкость написания
	3.  (-) Простота верификации
133. [Трансляция программ] python это
	0.  (+) интерпретатор
	1.  (-) компилятор
	2.  (-) программатор
	3.  (-) ретранслятор
134. [Трансляция программ] Необязательным этапом трансляции программы является
	0.  (+) оптимизация
	1.  (-) лексический анализ
	2.  (-) компоновка
	3.  (-) семантический анализ
135. [Процессы Windows] File mapping — это
	0.  (+) Механизм отображения содержимого файла в виртуальное адресное пространство процесса
	1.  (-) Конвеер для преобразования файла
	2.  (-) Механизм отображения содержимого файла в оперативную память
	3.  (-) Часть виртуального адресного пространства процесса, которую он использует для доступа к файлу
136. [Процессы Windows] Очередь готовности — это
	0.  (+) очередь процессов, размещенных в памяти и ожидающих выполнения
	1.  (-) очередь процессов, завершивших свое выполнения и ожидающих выгрузки из памяти
	2.  (-) очередь процессов, ожидающих освобождения устройства ввода-вывода
	3.  (-) Правильного варианта нет
137. [Процессы Windows] Событие — это объект синхронизации
	0.  (+) который используется для того, чтобы сигнализировать другим потокам о наступлении чего-либо
	1.  (-) используемый для обеспечения монопольного доступа к некоторому ресурсу со стороны нескольких потоков
	2.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
	3.  (-) применяемый для учета использования ресурсов
138. [Процессы Windows] К состояниям процесса не относится
	0.  (+) Переключение контекста
	1.  (-) Готовности к запуску
	2.  (-) Выполнения
	3.  (-) Ожидания
139. [Процессы Windows] Представить планирование выполнения процессов в системе можно с помощью
	0.  (+) Диаграммы очередей
	1.  (-) Диаграммы стеков
	2.  (-) Схемы распределения
	3.  (-) Очереди готовности
140. [Процессы Windows] Состояние взаимоблокировки возникает
	0.  (+) При ожидании процессами ресурсов, захваченных друг другом
	1.  (-) При ошибке проектирования многопоточной системы, выражающейся в зависимости от порядка выполнения кода
	2.  (-) При исключительной ситуации
	3.  (-) При аппаратном прерывании
141. [Процессы Windows] Мьютекс — это объект синхронизации
	0.  (+) используемый для обеспечения монопольного доступа к некоторому ресурсу со стороны нескольких потоков
	1.  (-) применяемый для учета использования ресурсов
	2.  (-) который применяется для уведомления потоков об окончании какой-либо операции.
	3.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
142. [Процессы Windows] PCB расшифровывается как
	0.  (+) Process control block
	1.  (-) Printed circuit board
	2.  (-) Polychlorinated biphenyl
	3.  (-) Police Complaints Board
143. [Процессы Windows] Переключение контекста происходит при
	0.  (+) Изменении выполняющегося в настоящий момент процесса
	1.  (-) Изменении активного потока
	2.  (-) Изменении активного ядра процессора
	3.  (-) Смене фокуса в оконном приложении
144. [Процессы Windows] Каждый процесс имеет как минимум один
	0.  (+) Поток
	1.  (-) Идентификатор
	2.  (-) Файловый дескриптор
	3.  (-) Приоритет
145. [Процессы Windows] Разделение памяти в ОС Windows позволяет
	0.  (+) Осуществлять межпроцессное взаимодействие
	1.  (-) Осуществить копирование файлов
	2.  (-) Осуществить передачу данных по сети
	3.  (-) Осуществить подключение к удаленному рабочему столу
146. [Процессы Windows] Создание разделяемой памяти начинается с вызова функции
	0.  (+) CreateFileMapping
	1.  (-) MapViewOfFile
	2.  (-) CopyMemory
	3.  (-) CloseHandle
147. [Процессы Windows] Представление файла (file view) — это
	0.  (+) Часть виртуального адресного пространства процесса, которую он использует для доступа к файлу
	1.  (-) Превдоним имени файла
	2.  (-) Отображение файла в оперативную память
	3.  (-) Его расширение
148. [Процессы Windows] Состояние гонки возникает
	0.  (+) При ошибке проектирования многопоточной системы, выражающейся в зависимости от порядка выполнения кода
	1.  (-) При ожидании процессами ресурсов, захваченных друг другом
	2.  (-) Как ответная реакция процессора на некорректную операцию ввода-вывода
	3.  (-) Ответная реакция системы на отсутствие страницы памяти
149. [Процессы Windows] Очередь устройств — это
	0.  (+) очередь процессов, ожидающих освобождения устройства ввода-вывода
	1.  (-) очередь процессов, размещенных в памяти и ожидающих выполнения
	2.  (-) Очередь физических устройств, ожидающих инициализации драйверов
	3.  (-) Правильного варианта нет
150. [Процессы Windows] Каждый процесс представляется в ОС в виде
	0.  (+) PCB
	1.  (-) IRP
	2.  (-) ARP
	3.  (-) ISR
151. [Процессы Windows] Именованный канал — это объект синхронизации
	0.  (+) являющийся средством межпроцессной коммуникации
	1.  (-) который используется для того, чтобы сигнализировать другим потокам о наступлении чего-либо
	2.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
	3.  (-) применяемый для учета использования ресурсов
152. [Процессы Windows] Критическая секция - это объект синхронизации
	0.  (+) представляющий собой участок исполняемого кода программы, в котором производится доступ к общему ресурсу и который не может быть выполнен более чем одним потоком выполнения
	1.  (-) используемый для обеспечения монопольного доступа к некоторому ресурсу со стороны нескольких потоков
	2.  (-) применяемый для учета использования ресурсов
	3.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
153. [Процессы Windows] Семафор — это объект синхронизации
	0.  (+) в основе которого лежит счетчик разрешений для доступа потоков к общему ресурсу
	1.  (-) который применяется для уведомления потоков об окончании какой-либо операции.
	2.  (-) представляющий собой участок исполняемого кода программы, в котором производится доступ к общему ресурсу и который не может быть выполнен более чем одним потоком выполнения
	3.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
154. [Прерывания] Уровень IRQL с самым низким приоритетом – это
	0.  (+) PASSIVE
	1.  (-) IPI
	2.  (-) Profile
	3.  (-) DPC/DISPATCH
155. [Прерывания] Прерывания, поступающие от источников с IRQL, равными или ниже текущего уровня…
	0.  (+) маскируются до тех пор, пока выполняющийся поток не понизит IRQL
	1.  (-) прерывают работу процессора и обрабатываются
	2.  (-) игнорируются и пропускаются
	3.  (-) не происходят
156. [Прерывания] Для выполнения APC пользовательского режима в контексте целевого потока
	0.  (+) Разрешение целевого потока требуется
	1.  (-) Разрешение целевого потока не требуется
	2.  (-) Разрешение целевого потока не требуется, но желательно
	3.  (-) Правильного варианта нет
157. [Прерывания] Cпециальная процедура, вызываемая по прерыванию для выполнения его обработки
	0.  (+) ISR
	1.  (-) APC
	2.  (-) DPC
	3.  (-) IoGetCurrentIrpStackLocation
158. [Прерывания] Для выполнения APC режима ядра в контексте целевого потока
	0.  (+) Разрешение целевого потока не требуется
	1.  (-) Разрешение целевого потока требуется
	2.  (-) Разрешение целевого потока не требуется, но желательно
	3.  (-) Правильного варианта нет
159. [Прерывания] Прерывания, поступающие от источника с IRQL, превышающим текущий уровень…
	0.  (+) прерывают работу процессора и обрабатываются
	1.  (-) маскируются до тех пор, пока выполняющийся поток не понизит IRQL
	2.  (-) игнорируются и пропускаются
	3.  (-) не происходят
160. [Прерывания] Этот уровень IRQL используется при взаимодействии процессоров и запроса на выполнение какой-то операции
	0.  (+) IPI
	1.  (-) High
	2.  (-) Clock
	3.  (-) DPC
161. [Прерывания] Уровень IRQL с самым высоким приоритетом – это
	0.  (+) High
	1.  (-) PASSIVE
	2.  (-) DPC
	3.  (-) DIRQL
162. [Прерывания] DIRQL — это
	0.  (+) Диапазон уровней прерываний устройств
	1.  (-) Уровень отложенного вызова процедур
	2.  (-) Уровень асинхронного вызова процедур
	3.  (-) Уровень для управления системными часами
163. [Прерывания] К возникновению исключения не приводит
	0.  (+) подключение флешки
	1.  (-) ошибка деления на ноль
	2.  (-) нарушение защиты памяти
	3.  (-) некоторые отладочные команды
164. [Прерывания] В ОС семества Windows NT х64 и IA64 количество уровней прерываний равно
	0.  (+) 16
	1.  (-) 32
	2.  (-) 64
	3.  (-) 8
165. [Прерывания] В ОС семества Windows NT x86 количество уровней прерываний равно
	0.  (+) 32
	1.  (-) 64
	2.  (-) 16
	3.  (-) 8
166. [Прерывания] Для поиска обработчика прерываний в Windows используется таблица
	0.  (+) IDT
	1.  (-) MDL
	2.  (-) SST
	3.  (-) GDT
167. [Прерывания] При DPC-вызове передача управления вызываемой процедуре
	0.  (+) не происходит сразу, а откладывается
	1.  (-) происходит сразу же
	2.  (-) не происходит
	3.  (-) происходит по таймеру
168. [Прерывания] IRQL — это
	0.  (+) Уровни прерываний
	1.  (-) Уровни исключений
	2.  (-) Процедура обработки прерываний
	3.  (-) Правильного варианта нет
169. [Грамматики по Хомскому] Грамматики по Хомскому типа 0 это -
	0.  (+) грамматики с фразовой структурой
	1.  (-) контекстно-зависимые грамматики
	2.  (-) контекстно-свободные грамматики
	3.  (-) регулярные (автоматные) грамматики
170. [Грамматики по Хомскому] Закончите фразу: "Грамматики с фразовой структурой ..."
	0.  (+) не имеют практического применения
	1.  (-) имеют практическое применение
	2.  (-) имеют в своей разновидности неукорачивающие грамматики
	3.  (-) имеют в своей разновидности укорачивающие грамматики
171. [Грамматики по Хомскому] Грамматики по Хомскому типа 1 это -
	0.  (+) контекстно-зависимые грамматики
	1.  (-) грамматики с фразовой структурой
	2.  (-) контекстно-свободные грамматики
	3.  (-) регулярные (автоматные) грамматики
172. [Грамматики по Хомскому] Контекстно-зависимые грамматики включают в себя
	0.  (+) неукорачивающие грамматики
	1.  (-) укорачивающие грамматики
	2.  (-) леволинейные грамматики
	3.  (-) праволинейные грамматики
173. [Грамматики по Хомскому] Грамматики по Хомскому типа 2 это -
	0.  (+) контекстно-свободные грамматики
	1.  (-) грамматики с фразовой структурой
	2.  (-) контекстно-зависимые грамматики
	3.  (-) регулярные (автоматные) грамматики
174. [Грамматики по Хомскому] Грамматики по Хомскому типа 3 это -
	0.  (+) регулярные (автоматные) грамматики
	1.  (-) грамматики с фразовой структурой
	2.  (-) контекстно-зависимые грамматики
	3.  (-) контекстно-свободные грамматики
175. [Грамматики по Хомскому] Регулярные (автоматные) грамматики включают в себя
	0.  (+) леволинейные грамматики
	1.  (-) неукорачивающие грамматики
	2.  (-) укорачивающие грамматики
	3.  (-) криволинейные грамматики
176. [Грамматики по Хомскому] Языки типа "0" по классификации Хомского это -
	0.  (+) языки с фразовой структурой
	1.  (-) контекстно-зависимые языки
	2.  (-) контекстно-свободные языки
	3.  (-) регулярные языки
177. [Грамматики по Хомскому] Языки типа "1" по классификации Хомского это -
	0.  (+) Контекстно-зависимые языки
	1.  (-) Языки с фразовой структурой
	2.  (-) Контекстно-свободные языки
	3.  (-) Регулярные языки
178. [Грамматики по Хомскому] Языки типа "2" по классификации Хомского это -
	0.  (+) контекстно-свободные языки
	1.  (-) языки с фразовой структурой
	2.  (-) контекстно-зависимые языки
	3.  (-) регулярные языки
179. [Грамматики по Хомскому] Языки типа "3" по классификации Хомского это -
	0.  (+) регулярные языки
	1.  (-) языки с фразовой структурой
	2.  (-) контекстно-свободные языки
	3.  (-) контекстно-зависимые
180. [Грамматики по Хомскому] Языки классифицируются в соответствии с(со)
	0.  (+) типом грамматики, с помощью которых они задаются
	1.  (-) кодировкой с помощью которых они задаются
	2.  (-) шрифтами с помощью которых они задаются
	3.  (-) личными предпочтениями программиста
181. [Грамматики по Хомскому] В случае, когда язык может быть задан с помощью большого количества грамматик, относящихся к разным типам, то из всех этих грамматик берется
	0.  (+) та, которая имеет максимальный номер класса
	1.  (-) та которая имеет минимальный номер класса
	2.  (-) наиболее сложная грамматика
	3.  (-) наиболее простая грамматика
182. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> aaCFD; 2) AD -> D; 3) F -> AFB| AB; 4) Cb -> bC; 5) AB -> bBA; 6) CB -> C; 7) Ab -> bA; 8) bCD -> e, где e - цепочка нулевой длины
	0.  (+) Тип 0.
	1.  (-) Тип 1.
	2.  (-) Тип 2.
	3.  (-) Тип 3.
183. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> At | Bt; 2) A -> a | Ba; 3) B -> b | Bb | Ab.
	0.  (+) Тип 3.
	1.  (-) Тип 0.
	2.  (-) Тип 1.
	3.  (-) Тип 2.
184. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> APA; 2) P -> "+" | -; 3) A -> a | b.
	0.  (+) Тип 2.
	1.  (-) Тип 0.
	2.  (-) Тип 1.
	3.  (-) Тип 3.
185. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> 1B; 2) B -> B0 | 1.
	0.  (+) Тип 3.
	1.  (-) Тип 0.
	2.  (-) Тип 1.
	3.  (-) Тип 2.
186. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> aSBC | abC; 2) CB -> BC; 3) bB -> bb; 4) bC -> bc; 5) cC -> cc.
	0.  (+) Тип 1.
	1.  (-) Тип 0.
	2.  (-) Тип 2.
	3.  (-) Тип 3.
187. [Грамматики по Хомскому] Регулярные грамматики включают в себя
	0.  (+) грамматики, выровненные влево
	1.  (-) неукорачивающие грамматики
	2.  (-) укорачивающие грамматики
	3.  (-) криволинейные грамматики
188. [Кодогенерация, промежуточное представление программы] Установление однозначного соответствия между лексическими единицами и их именами в тексте программы - это
	0.  (+) идентификация
	1.  (-) декодирование
	2.  (-) расшифровка
	3.  (-) кодирование
189. [Кодогенерация, промежуточное представление программы] ассемблер - это
	0.  (+) язык низкого уровня
	1.  (-) язык высокого уровня
	2.  (-) язык среднего уровня
	3.  (-) язык нулевого уровня
190. [Кодогенерация, промежуточное представление программы] Что из перечисленного не является промежуточным языком
	0.  (+) С++
	1.  (-) байт-код
	2.  (-) p-код
	3.  (-) ассемблер
191. [Кодогенерация, промежуточное представление программы] При динамическом распределении памяти объекты
	0.  (+) Размещаются в куче
	1.  (-) Размещаются в динамических библиотеках
	2.  (-) В памяти процесса
	3.  (-) Размещаются в стеке
192. [Кодогенерация, промежуточное представление программы] Память, динамически выделенная
	0.  (+) Может хранится до перезагрузки ОС
	1.  (-) Может хранится до момента завершения функции, в которой она выделяется
	2.  (-) Может хранится до момента завершения программы
	3.  (-) Может хранится после перезагрузки ОС
193. [Кодогенерация, промежуточное представление программы] Недостатки динамической памяти
	0.  (+) Возможны утечки, когда выделенная память не освбождается
	1.  (-) При запуске программы сразу забирается максимально возможный объем памяти
	2.  (-) Скорость работы снижена в несколько раз
	3.  (-) Память нельзя освободить до перезагрузки
194. [Кодогенерация, промежуточное представление программы] Кодогенерация
	0.  (+) может быть как промежуточным, так и финальным этапом трансляции
	1.  (-) это финальный этап трансляции
	2.  (-) это промежуточный этап трансляции
	3.  (-) это начальный этап трансляции
195. [Кодогенерация, промежуточное представление программы] Идентификация это
	0.  (+) установление однозначного соответствия между лексическими единицами, их именами в тексте программы
	1.  (-) установление однозначого соответствия между лексическими единицами и адресами в памяти для этих единиц
	2.  (-) установления однозначного соответствия между инструкциями исходного кода и машинных команд
	3.  (-) установление однозначного соответствия между лексическими единицами и триадами
196. [Кодогенерация, промежуточное представление программы] Основная идея метода синтаксически управляемого перевода
	0.  (+) синтаксис и семантика языка связаны
	1.  (-) синтаксис и семантика языка не связаны
	2.  (-) синтаксис и семантика языка тождественны
	3.  (-) смысл предложений языка не зависит от синтаксической структуры предложения
197. [Кодогенерация, промежуточное представление программы] Назовите неправильное утверждение
	0.  (+) Синтаксическое дерево – это граф в виде дерева, вершины которого соответствуют операндам, а листья представляют собой операции
	1.  (-) Синтаксическое дерево – это граф в виде дерева, вершины которого соответствуют операциям, а листья представляют собой операнды
	2.  (-) Листья синтаксического дерева связаны с записями в таблице идентификаторов
	3.  (-) Синтаксическое дерево - результат работы синтаксического анализатора
198. [Кодогенерация, промежуточное представление программы] Дерево операций
	0.  (+) можно построить непосредственно из дерева вывода
	1.  (-) включает в себя дерево вывода
	2.  (-) эквивалентно дереву вывода
	3.  (-) нельзя построить из дерева вывода
199. [Кодогенерация, промежуточное представление программы] Для формирования внутреннего представления программы может применяться
	0.  (+) все другие варианты
	1.  (-) постфиксная запись (ПОЛИЗ)
	2.  (-) многоадресный код с явно именуемыми результатами (тетрада)
	3.  (-) многоадресный код с неявно именуемыми результатами (триада)
200. [Кодогенерация, промежуточное представление программы] ПОЛИЗ — это
	0.  (+) Форма промежуточного представления программы, в которой используется постфиксная форма записи операций
	1.  (-) Форма промежуточного представления программы, в которой используется префиксная форма записи операций
	2.  (-) Форма промежуточного представления программы, в которой операции представляются в виде (<знак_операции>, <первый_операнд>, <второй_операнд>).
	3.  (-) Форма промежуточного представления программы, в которой используется дерево операций
201. [Кодогенерация, промежуточное представление программы] Преимущество триад при промежуточном представлении программы перед тетрадами в том, что
	0.  (+) Требуют меньше памяти
	1.  (-) Не зависят от архитектуры вычислительной системы
	2.  (-) Представляют собой линейную последовательность, для которой несложно написать преобразующий алгоритм в команды результирующей программы
	3.  (-) Ничего из перечисленного
202. [Кодогенерация, промежуточное представление программы] Выберите ПОЛИЗ для выражения (2+5) * (5-8) / 3
	0.  (+) 2 5 + 5 8 - * 3 /
	1.  (-) (2+5) * (5-8) / 3
	2.  (-) / * + 2 5 - 5 8 3
	3.  (-) 2 5 + 5 8 - / 3 *
203. [Кодогенерация, промежуточное представление программы] Выберите ПОЛИЗ для выражения (4-2) * 4 / 5
	0.  (+) 4 2 - 4 * 5 /
	1.  (-) 4 2 - 4 * 5
	2.  (-) 4 2 - 4 / 5 *
	3.  (-) 2 4 - 4 * 5 /
204. [Кодогенерация, промежуточное представление программы] Промежуточный код
	0.  (+) может иметь любую структуру в зависимости от реализации компилятора
	1.  (-) всегда представляет собой линейную последовательность команд
	2.  (-) тождественен объектной программе
	3.  (-) может быть представлен только в виде программы на ассемблере
205. [Кодогенерация, промежуточное представление программы] К достоинствам триадного представления промежуточного кода не относится
	0.  (+) необходимость создания алгоритма, отвечающего за распределение памяти для хранения промежуточных результатов
	1.  (-) занимают меньше памяти, чем тетрады, дают больше возможностей по оптимизации программы, чем обратная польская запись
	2.  (-) промежуточные результаты вычисления могут храниться в регистрах процессора
	3.  (-) по форме представления находятся ближе к двухадресным машинным командам,чем другие формы внутреннего представления программ
206. [Кодогенерация, промежуточное представление программы] К недостаткам тетрадного представления промежуточного кода относится
	0.  (+) есть сложности с непосредственным преобразованием в машинный код
	1.  (-) являются линейной последовательностью операций, в отличие от синтаксического дерева, и потому проще преобразуются в результирующий код
	2.  (-) в отличие от команд ассемблера на зависят от архитектуры вычислительной системы
	3.  (-) дают больше возможностей по оптимизации программы, чем обратная польская запись
207. [Формальные языки и грамматики (определения)] Что такое грамматика
	0.  (+) Наука изучающая способ построения языка
	1.  (-) Наука, изучающая смысловое значение единиц языка
	2.  (-) Наука, изучающая морфологические модели языка
	3.  (-) Наука, изучающая множество лексем
208. [Формальные языки и грамматики (определения)] Символ (буква) в формальных языках – это
	0.  (+) простой, неделимый знак
	1.  (-) счетное множество допустимых символов языка
	2.  (-) произвольная упорядоченная конечная последовательность знаков алфавита
	3.  (-) конечный результат любой закодированной информации
209. [Формальные языки и грамматики (определения)] Алфавит в формальных языках – это
	0.  (+) счетное множество допустимых символов языка
	1.  (-) простой, неделимый знак
	2.  (-) произвольная, упорядоченная конечная последовательность знаков алфавита
	3.  (-) звуковое, буквенное выражение закодированной информации
210. [Формальные языки и грамматики (определения)] Слова в формальных языках - это
	0.  (+) все последовательности терминалов, выводимые (порождаемые) из начального нетерминала по правилам вывода, заданного грамматикой
	1.  (-) счетное множество допустимых символов языка
	2.  (-) произвольная упорядоченная конечная последовательность знаков алфавита
	3.  (-) конечный результат любой закодированной информации
211. [Формальные языки и грамматики (определения)] Все существующие формальные языки строятся на основе
	0.  (+) различных конечных алфавитов
	1.  (-) бесконечных алфавитов
	2.  (-) беззнаковых алфавитах
	3.  (-) кодировкой Unicode
212. [Формальные языки и грамматики (определения)] Цепочка символов (строка) - это
	0.  (+) произвольная, упорядоченная конечная последовательность знаков алфавита
	1.  (-) простой неделимый знак
	2.  (-) счетное множество допустимых символов языка
	3.  (-) цепочка символов представленная в определенной последовательности
213. [Формальные языки и грамматики (определения)] В формальных языках и грамматиках цепочка ω называется подцепочкой γ, если γ=
	0.  (+) αωβ
	1.  (-) γ(ω)
	2.  (-) ω(γ)
	3.  (-) αγβ
214. [Формальные языки и грамматики (определения)] Язык L над алфавитом А: L(A) это некоторое счетное подмножество цепочек конечной длины из множества всех цепочек алфавита А: (in — является подмножеством)
	0.  (+) L(A) in А*
	1.  (-) А* in L(A)
	2.  (-) L(A) in А
	3.  (-) A(L) in L
215. [Формальные языки и грамматики (определения)] В формальных языках лексика это -
	0.  (+) совокупность слов (словарный запас) языка
	1.  (-) конструкция, которая состоит из элементов алфавита языка и не содержит в себе других конструкций
	2.  (-) набор правил, определяющий допустимые конструкции языка, т.е. задает набор цепочек символов, которые принадлежат языку
	3.  (-) раздел языка, определяющий значение предложений языка, т.е. задает смысл всех допустимых цепочек языка
216. [Формальные языки и грамматики (определения)] В формальных языках лексема это -
	0.  (+) конструкция которая состоит из элементов алфавита языка и не содержит в себе других конструкций
	1.  (-) совокупность слов, словарный запас языка
	2.  (-) набор правил, определяющий допустимые конструкции языка, т.е. задает набор цепочек символов, которые принадлежат языку
	3.  (-) раздел языка, определяющий значение предложений языка, т.е. задает смысл всех допустимых цепочек языка
217. [Формальные языки и грамматики (определения)] В формальных языках синтаксис это -
	0.  (+) набор правил, определяющий допустимые конструкции языка, т.е. задает набор цепочек символов, которые принадлежат языку
	1.  (-) совокупность слов, словарный запас языка
	2.  (-) конструкция, которая состоит из элементов алфавита языка и не содержит в себе других конструкций
	3.  (-) раздел языка, определяющий значение предложений языка, т.е. задает смысл всех допустимых цепочек языка
218. [Формальные языки и грамматики (определения)] В формальных языках семантика это -
	0.  (+) раздел языка, определяющий значение предложений языка, т.е. задает смысл всех допустимых цепочек языка
	1.  (-) совокупность слов, словарный запас языка
	2.  (-) конструкция, которая состоит из элементов алфавита языка и не содержит в себе других конструкций
	3.  (-) набор правил, определяющий допустимые конструкции языка, т.е. задает набор цепочек символов, которые принадлежат языку
219. [Формальные языки и грамматики (определения)] Для задания ЯП необходимо
	0.  (+) все ответы правильные
	1.  (-) определить множество допустимых символов языка
	2.  (-) определить множество правильных программ языка
	3.  (-) задать смысл для каждой правильной программы
220. [Формальные языки и грамматики (определения)] Какая из проблем не решается в теории формальных языков
	0.  (+) задать смысл для каждой правильной программы
	1.  (-) определить множество правильных программ языка
	2.  (-) определить множество допустимых символов языка
	3.  (-) в теории формальных языков нет нерешаемых проблем
221. [Формальные языки и грамматики (определения)] Что можно описать в виде строгого набора правил?
	0.  (+) только формальные языки.
	1.  (-) только неформальные языки
	2.  (-) формальные и неформальные языки
	3.  (-) почти все ЯП
222. [Формальные языки и грамматики (определения)] Язык L над алфавитом А – это
	0.  (+) подмножество цепочек А*
	1.  (-) подмножество цепочек А
	2.  (-) подмножество цепочек L
	3.  (-) подмножество цепочек L*
223. [Формальные языки и грамматики (определения)] Формальная грамматика - это
	0.  (+) способ описания формального языка, выделение некоторого подмножества из множества всех слов некоторого конечного алфавита
	1.  (-) множество атомарных (неделимых) символов какого-либо формального языка
	2.  (-) условно верное написание формальных символов
	3.  (-) подвид грамматик Хомского
224. [Формальные языки и грамматики (определения)] Алфавит формального языка - это
	0.  (+) множество атомарных (неделимых) символов какого-либо формального языка
	1.  (-) способ описания формального языка и выделение некоторого подмножества из множества всех слов некоторого конечного алфавита
	2.  (-) форма письменности основанная на нестандартном наборе знаков
	3.  (-) подвид языков Хомского
