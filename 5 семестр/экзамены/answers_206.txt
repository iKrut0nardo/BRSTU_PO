0. [Грамматики по Хомскому] В случае, когда язык может быть задан с помощью большого количества грамматик, относящихся к разным типам, то из всех этих грамматик берется
	0.  (+) та, которая имеет максимальный номер класса
	1.  (-) та которая имеет минимальный номер класса
	2.  (-) наиболее сложная грамматика
	3.  (-) наиболее простая грамматика
1. [Грамматики по Хомскому] Грамматики по Хомскому типа 0 это -
	0.  (+) грамматики с фразовой структурой
	1.  (-) контекстно-зависимые грамматики
	2.  (-) контекстно-свободные грамматики
	3.  (-) регулярные (автоматные) грамматики
2. [Грамматики по Хомскому] Грамматики по Хомскому типа 1 это -
	0.  (+) контекстно-зависимые грамматики
	1.  (-) грамматики с фразовой структурой
	2.  (-) контекстно-свободные грамматики
	3.  (-) регулярные (автоматные) грамматики
3. [Грамматики по Хомскому] Грамматики по Хомскому типа 2 это -
	0.  (+) контекстно-свободные грамматики
	1.  (-) грамматики с фразовой структурой
	2.  (-) контекстно-зависимые грамматики
	3.  (-) регулярные (автоматные) грамматики
4. [Грамматики по Хомскому] Грамматики по Хомскому типа 3 это -
	0.  (+) регулярные (автоматные) грамматики
	1.  (-) грамматики с фразовой структурой
	2.  (-) контекстно-зависимые грамматики
	3.  (-) контекстно-свободные грамматики
5. [Грамматики по Хомскому] Закончите фразу: "Грамматики с фразовой структурой ..."
	0.  (+) не имеют практического применения
	1.  (-) имеют практическое применение
	2.  (-) имеют в своей разновидности неукорачивающие грамматики
	3.  (-) имеют в своей разновидности укорачивающие грамматики
6. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> 1B; 2) B -> B0 | 1.
	0.  (+) Тип 3.
	1.  (-) Тип 0.
	2.  (-) Тип 1.
	3.  (-) Тип 2.
7. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> aaCFD; 2) AD -> D; 3) F -> AFB| AB; 4) Cb -> bC; 5) AB -> bBA; 6) CB -> C; 7) Ab -> bA; 8) bCD -> e, где e - цепочка нулевой длины
	0.  (+) Тип 0.
	1.  (-) Тип 1.
	2.  (-) Тип 2.
	3.  (-) Тип 3.
8. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> APA; 2) P -> "+" | -; 3) A -> a | b.
	0.  (+) Тип 2.
	1.  (-) Тип 0.
	2.  (-) Тип 1.
	3.  (-) Тип 3.
9. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> aSBC | abC; 2) CB -> BC; 3) bB -> bb; 4) bC -> bc; 5) cC -> cc.
	0.  (+) Тип 1.
	1.  (-) Тип 0.
	2.  (-) Тип 2.
	3.  (-) Тип 3.
10. [Грамматики по Хомскому] Определите тип языка, заданного правилами вывода: 1) S -> At | Bt; 2) A -> a | Ba; 3) B -> b | Bb | Ab.
	0.  (+) Тип 3.
	1.  (-) Тип 0.
	2.  (-) Тип 1.
	3.  (-) Тип 2.
11. [Грамматики по Хомскому] Регулярные грамматики включают в себя
	0.  (+) грамматики, выровненные влево
	1.  (-) неукорачивающие грамматики
	2.  (-) укорачивающие грамматики
	3.  (-) криволинейные грамматики
12. [Грамматики по Хомскому] Языки классифицируются в соответствии с(со)
	0.  (+) типом грамматики, с помощью которых они задаются
	1.  (-) кодировкой с помощью которых они задаются
	2.  (-) шрифтами с помощью которых они задаются
	3.  (-) личными предпочтениями программиста
13. [Грамматики по Хомскому] Языки типа "0" по классификации Хомского это -
	0.  (+) языки с фразовой структурой
	1.  (-) контекстно-зависимые языки
	2.  (-) контекстно-свободные языки
	3.  (-) регулярные языки
14. [Грамматики по Хомскому] Языки типа "1" по классификации Хомского это -
	0.  (+) Контекстно-зависимые языки
	1.  (-) Языки с фразовой структурой
	2.  (-) Контекстно-свободные языки
	3.  (-) Регулярные языки
15. [Грамматики по Хомскому] Языки типа "2" по классификации Хомского это -
	0.  (+) контекстно-свободные языки
	1.  (-) языки с фразовой структурой
	2.  (-) контекстно-зависимые языки
	3.  (-) регулярные языки
16. [Грамматики по Хомскому] Языки типа "3" по классификации Хомского это -
	0.  (+) регулярные языки
	1.  (-) языки с фразовой структурой
	2.  (-) контекстно-свободные языки
	3.  (-) контекстно-зависимые
17. [Грамматики по Хомскому] Контекстно-зависимые грамматики включают в себя
	0.  (+) неукорачивающие грамматики
	1.  (-) укорачивающие грамматики
	2.  (-) леволинейные грамматики
	3.  (-) праволинейные грамматики
18. [Грамматики по Хомскому] Регулярные (автоматные) грамматики включают в себя
	0.  (+) леволинейные грамматики
	1.  (-) неукорачивающие грамматики
	2.  (-) укорачивающие грамматики
	3.  (-) криволинейные грамматики
19. [Грамматики по Хомскому] Грамматики, определяющие один и тот же язык, называются
	0.  (+) Эквивалентными
	1.  (-) Квазирегулярными
	2.  (-) Равными
	3.  (-) Тождественными
20. [Грамматики по Хомскому] Грамматики, для которых определяемые ими языки различаются не более чем на пустую цепочку символов, называются
	0.  (+) почти эквивалентными
	1.  (-) квазиэквивалентными
	2.  (-) равными
	3.  (-) парными
21. [Интернет вещей] Arduino — это
	0.  (+) Марка аппаратно-программных средств для разработки АС
	1.  (-) Плата расширения для персонального компьютера
	2.  (-) IoT-технология
	3.  (-) Детский развивающий конструктор
22. [Интернет вещей] Industry 4.0 характеризуется
	0.  (+) Высокой степенью вовлеченности современных информационных технологий в промышленное производство
	1.  (-) Применением систем дистанционного образования
	2.  (-) Миниатюризацией компьютерной техники
	3.  (-) Увеличением тактовой частоты процессоров
23. [Интернет вещей] IoT - это
	0.  (+) Internet of Things
	1.  (-) Internet of Thoughts
	2.  (-) Internet of Tons
	3.  (-) Internet of Trends
24. [Интернет вещей] RFID-метка - это
	0.  (+) Устройство, позволяющее автоматически идентифицировать объекты посредством радиосигналов
	1.  (-) Устройство, позволяющее считывать радиосигналы, поступающие извне
	2.  (-) Устройство контроля задымленности
	3.  (-) Устройство мониторинга радиационной загрязненности
25. [Интернет вещей] К предпосылкам развития Интернета вещей можно отнести
	0.  (+) Все перечисленное
	1.  (-) совершенствование микроконтроллеров
	2.  (-) ускорение Интернет
	3.  (-) накопление большого массива данных
26. [Интернет вещей] К примерам проектов IoT можно отнести
	0.  (+) Все перечисленные варианты
	1.  (-) Рекомендательная система для фермерских хозяйств для выработки решений относительно ухода за земельными участками
	2.  (-) Система мониторинга воздействия городов на окружающую среду для снижения отрицательного воздействия деятельности человека
	3.  (-) Система, контролирующая суточное потребление воды и пищи человеком и дающая рекомендации по здоровому питанию
27. [Интернет вещей] К типичным примерам применения технологии IoT относится
	0.  (+) Все перечисленное
	1.  (-) Удаленное отслеживания состояния оборудования и прогнозирование поломок
	2.  (-) Решения для контроля состояния спортсменов и накопления статистики
	3.  (-) Системы контроля потребления ресурсов домовладениями
28. [Интернет вещей] Ключевая особенность технологии IoT - это
	0.  (+) взаимодействие устройств без участия человека
	1.  (-) распределенность сетевой нагрузки между поставщиками услуг
	2.  (-) моделирование интеллектуальной деятельности человека
	3.  (-) локальность (ограниченность) распространения
29. [Интернет вещей] Основной недостаток технологии IoT
	0.  (+) безопасность
	1.  (-) высокая стоимость
	2.  (-) скорость работы
	3.  (-) сложность разработки
30. [Интернет вещей] Технология IIoT - это
	0.  (+) Industrial Internet of Things
	1.  (-) Incremental Internet of Things
	2.  (-) Intellectual Internet of Things
	3.  (-) Intermediate Internet of Things
31. [Интернет вещей] К устройствам IoT не относится
	0.  (+) Мобильный телефон
	1.  (-) Фитнес-браслет
	2.  (-) "Умный" термостат
	3.  (-) Кофеварка с возможностью удаленного управления
32. [Интернет вещей] К основным компонентам технологии IoT не относится
	0.  (-) Сенсоры
	1.  (-) Пользовательский интерфейс
	2.  (-) Обработка данных
	3.  (+) IIoT
33. [Интернет вещей] Arduino Uno - это
	0.  (+) Микроконтроллерная плата
	1.  (-) Марка сенсора
	2.  (-) Фирма-производитель микроконтроллеров
	3.  (-) Стандарт связи
34. [Интернет вещей] Устройства IoT получают данные от внешней среды с помощью
	0.  (+) Сенсоров
	1.  (-) Каналов связи
	2.  (-) Пользователей
	3.  (-) Серверов
35. [Интернет вещей] Arduino Nano - это
	0.  (-) Марка микроконтроллера
	1.  (-) Одноплатный компьютер
	2.  (+) Микроконтроллерная плата
	3.  (-) Форм-фактор настольного ПК
36. [Интернет вещей] Характерная черта серии микроконтроллеров Esp32/Esp8266
	0.  (-) Поддержка Ethernet-сети передачи данных
	1.  (-) Наличие встроенной камеры
	2.  (-) Наличие встроенных датчиков температуры, влажности и атмосферного давления
	3.  (+) Наличие модуля Wi-fi
37. [Интернет вещей] Микроконтроллер - это
	0.  (+) микросхема, предназначенная для управления электронными устройствами
	1.  (-) микросхема, предназначенная для управления аналоговыми устройствами
	2.  (-) составная часть процессора
	3.  (-) очень маленькая микросхема для сложных вычислений
38. [Кодогенерация, промежуточное представление программы] ассемблер - это
	0.  (+) язык низкого уровня
	1.  (-) язык высокого уровня
	2.  (-) язык среднего уровня
	3.  (-) язык нулевого уровня
39. [Кодогенерация, промежуточное представление программы] Выберите ПОЛИЗ для выражения (2+5) * (5-8) / 3
	0.  (+) 2 5 + 5 8 - * 3 /
	1.  (-) (2+5) * (5-8) / 3
	2.  (-) / * + 2 5 - 5 8 3
	3.  (-) 2 5 + 5 8 - / 3 *
40. [Кодогенерация, промежуточное представление программы] Выберите ПОЛИЗ для выражения (4-2) * 4 / 5
	0.  (+) 4 2 - 4 * 5 /
	1.  (-) 4 2 - 4 * 5
	2.  (-) 4 2 - 4 / 5 *
	3.  (-) 2 4 - 4 * 5 /
41. [Кодогенерация, промежуточное представление программы] Дерево операций
	0.  (+) можно построить непосредственно из дерева вывода
	1.  (-) включает в себя дерево вывода
	2.  (-) эквивалентно дереву вывода
	3.  (-) нельзя построить из дерева вывода
42. [Кодогенерация, промежуточное представление программы] Для формирования внутреннего представления программы может применяться
	0.  (+) все другие варианты
	1.  (-) постфиксная запись (ПОЛИЗ)
	2.  (-) многоадресный код с явно именуемыми результатами (тетрада)
	3.  (-) многоадресный код с неявно именуемыми результатами (триада)
43. [Кодогенерация, промежуточное представление программы] Идентификация это
	0.  (+) установление однозначного соответствия между лексическими единицами, их именами в тексте программы
	1.  (-) установление однозначого соответствия между лексическими единицами и адресами в памяти для этих единиц
	2.  (-) установления однозначного соответствия между инструкциями исходного кода и машинных команд
	3.  (-) установление однозначного соответствия между лексическими единицами и триадами
44. [Кодогенерация, промежуточное представление программы] К достоинствам триадного представления промежуточного кода не относится
	0.  (+) необходимость создания алгоритма, отвечающего за распределение памяти для хранения промежуточных результатов
	1.  (-) занимают меньше памяти, чем тетрады, дают больше возможностей по оптимизации программы, чем обратная польская запись
	2.  (-) промежуточные результаты вычисления могут храниться в регистрах процессора
	3.  (-) по форме представления находятся ближе к двухадресным машинным командам,чем другие формы внутреннего представления программ
45. [Кодогенерация, промежуточное представление программы] К недостаткам тетрадного представления промежуточного кода относится
	0.  (+) есть сложности с непосредственным преобразованием в машинный код
	1.  (-) являются линейной последовательностью операций, в отличие от синтаксического дерева, и потому проще преобразуются в результирующий код
	2.  (-) в отличие от команд ассемблера на зависят от архитектуры вычислительной системы
	3.  (-) дают больше возможностей по оптимизации программы, чем обратная польская запись
46. [Кодогенерация, промежуточное представление программы] Кодогенерация
	0.  (+) может быть как промежуточным, так и финальным этапом трансляции
	1.  (-) это финальный этап трансляции
	2.  (-) это промежуточный этап трансляции
	3.  (-) это начальный этап трансляции
47. [Кодогенерация, промежуточное представление программы] Назовите неправильное утверждение
	0.  (+) Синтаксическое дерево – это граф в виде дерева, вершины которого соответствуют операндам, а листья представляют собой операции
	1.  (-) Синтаксическое дерево – это граф в виде дерева, вершины которого соответствуют операциям, а листья представляют собой операнды
	2.  (-) Листья синтаксического дерева связаны с записями в таблице идентификаторов
	3.  (-) Синтаксическое дерево - результат работы синтаксического анализатора
48. [Кодогенерация, промежуточное представление программы] Основная идея метода синтаксически управляемого перевода
	0.  (+) синтаксис и семантика языка связаны
	1.  (-) синтаксис и семантика языка не связаны
	2.  (-) синтаксис и семантика языка тождественны
	3.  (-) смысл предложений языка не зависит от синтаксической структуры предложения
49. [Кодогенерация, промежуточное представление программы] ПОЛИЗ — это
	0.  (+) Форма промежуточного представления программы, в которой используется постфиксная форма записи операций
	1.  (-) Форма промежуточного представления программы, в которой используется префиксная форма записи операций
	2.  (-) Форма промежуточного представления программы, в которой операции представляются в виде (<знак_операции>, <первый_операнд>, <второй_операнд>).
	3.  (-) Форма промежуточного представления программы, в которой используется дерево операций
50. [Кодогенерация, промежуточное представление программы] Преимущество триад при промежуточном представлении программы перед тетрадами в том, что
	0.  (+) Требуют меньше памяти
	1.  (-) Не зависят от архитектуры вычислительной системы
	2.  (-) Представляют собой линейную последовательность, для которой несложно написать преобразующий алгоритм в команды результирующей программы
	3.  (-) Ничего из перечисленного
51. [Кодогенерация, промежуточное представление программы] Промежуточный код
	0.  (+) может иметь любую структуру в зависимости от реализации компилятора
	1.  (-) всегда представляет собой линейную последовательность команд
	2.  (-) тождественен объектной программе
	3.  (-) может быть представлен только в виде программы на ассемблере
52. [Кодогенерация, промежуточное представление программы] Установление однозначного соответствия между лексическими единицами и их именами в тексте программы - это
	0.  (+) идентификация
	1.  (-) декодирование
	2.  (-) расшифровка
	3.  (-) кодирование
53. [Кодогенерация, промежуточное представление программы] Что из перечисленного не является промежуточным языком
	0.  (+) С++
	1.  (-) байт-код
	2.  (-) p-код
	3.  (-) ассемблер
54. [Кодогенерация, промежуточное представление программы] Недостатки динамической памяти
	0.  (+) Возможны утечки, когда выделенная память не освбождается
	1.  (-) При запуске программы сразу забирается максимально возможный объем памяти
	2.  (-) Скорость работы снижена в несколько раз
	3.  (-) Память нельзя освободить до перезагрузки
55. [Кодогенерация, промежуточное представление программы] Память, динамически выделенная
	0.  (+) Может хранится до перезагрузки ОС
	1.  (-) Может хранится до момента завершения функции, в которой она выделяется
	2.  (-) Может хранится до момента завершения программы
	3.  (-) Может хранится после перезагрузки ОС
56. [Кодогенерация, промежуточное представление программы] При динамическом распределении памяти объекты
	0.  (+) Размещаются в куче
	1.  (-) Размещаются в динамических библиотеках
	2.  (-) В памяти процесса
	3.  (-) Размещаются в стеке
57. [Оптимизация кода] Для линейных участков не могут выполняться следующие виды оптимизации
	0.  (+) развертка объектного кода
	1.  (-) удаление бесполезных присваиваний
	2.  (-) исключение лишних вычислений
	3.  (-) перестановка операций
58. [Оптимизация кода] К приемам оптимизации линейных участков программы не относится
	0.  (+) вынесение инвариантных вычислений из циклов
	1.  (-) удаление бесполезных присваиваний
	2.  (-) исключение избыточных вычислений (лишних операций)
	3.  (-) арифметические преобразования
59. [Оптимизация кода] К приемам оптимизации не относится
	0.  (+) извлечение метода
	1.  (-) подстановка кода функции в вызывающий объектный код
	2.  (-) передача параметров через регистры процессора
	3.  (-) слияние и развертывание циклов
60. [Оптимизация кода] К приемам оптимизации циклов не относится
	0.  (+) свертка операций объектного кода
	1.  (-) вынесение инвариантных вычислений из циклов
	2.  (-) замена операций с индуктивными переменными
	3.  (-) слияние и развертывание циклов
61. [Оптимизация кода] Линейный участок программы
	0.  (+) выполняемая по порядку последовательность операций имеющая один вход и один выход
	1.  (-) выполняемая по приоритету последовательность операций, имеющая один вход и один выход
	2.  (-) выполняемая по порядку последовательность операций, имеющая один вход и множество выходов
	3.  (-) выполняемая по порядку последовательность операций, имеющая множество входов и один выход
62. [Оптимизация кода] обработка, связанная с переупорядочиванием и изменением операций в компилируемой программе с целью получения более эффективной результирующей объектной программы
	0.  (+) Оптимизация
	1.  (-) Генерация промежуточного кода
	2.  (-) Рефакторинг
	3.  (-) Семантический анализ
63. [Оптимизация кода] Особенностью оптимизации как этапа трансляции является
	0.  (+) ее необязательность
	1.  (-) ее обязательность
	2.  (-) потенциальная невозможность
	3.  (-) правильного варианта нет
64. [Оптимизация кода] Что является критериями оптимизации кода
	0.  (+) размер и скорость
	1.  (-) только скорость
	2.  (-) размер и сложность
	3.  (-) скорость и сложность
65. [Практика (Linux)] Вы находитесь в каталоге /var/opt. Просмотрите первые 10 строк файла /home/user/mytxt, используя относительное имя файла
	0.  (+) head -10 ../../home/user/mytxt
	1.  (-) head -10 /home/user/mytxt
	2.  (-) head -10 ././././home/user/mytxt
	3.  (-) head -10 ~/../home/user/mytxt
66. [Практика (Linux)] Вы находитесь в каталоге /opt/pycharm. Просмотрите первые 10 строк файла ~/mytxt, используя абсолютное имя файла
	0.  (+) head -10 /home/user/mytxt
	1.  (-) ls -10 /home/user/mytxt
	2.  (-) tail -10 /home/user/mytxt
	3.  (-) more -10 /home/user/mytxt
67. [Практика (Linux)] Вы находитесь в каталоге /usr/local/bin. Где вы окажетесь после применения команды cd /../../../../etc/././..
	0.  (+) /
	1.  (-) /etc
	2.  (-) /etc/./.
	3.  (-) /..
68. [Практика (Linux)] Вы находитесь в каталоге /usr/local/bin. Где вы окажетесь после применения команды cd /../var/./././
	0.  (+) /var
	1.  (-) /usr/local/var
	2.  (-) /usr/local/bin/var
	3.  (-) /usr/var
69. [Практика (Linux)] Вы находитесь в каталоге ~. Где вы окажетесь после применения команды cd ../../../../../../../..
	0.  (+) /
	1.  (-) ../../..
	2.  (-) ../../../../../../../..
	3.  (-) ./././././././.
70. [Практика (Linux)] Вы находитесь в каталоге ~. Где вы окажетесь после применения команды cd ../././././././vasia/./.././brother
	0.  (+) /home/brother
	1.  (-) /home/vasia/brother
	2.  (-) /home/vasia
	3.  (-) /brother
71. [Практика (Linux)] Вы находитесь в каталоге ~. Где вы окажетесь после применения команды cd 1/2/3/././4/././..
	0.  (+) /home/user/1/2/3
	1.  (-) /home/1/2/3
	2.  (-) /1/2/3
	3.  (-) /home/2/3
72. [Практика (Linux)] Вы находитесь в каталоге ~/. Просмотрите первые 10 строк файла /etc/group, используя относительное имя файла
	0.  (+) head -10 ../../etc/group
	1.  (-) head -10 ~/etc/group
	2.  (-) head -10 ././etc/./group
	3.  (-) head -10 ./././etc/group
73. [Практика (Linux)] Поменяйте владельца и группу файла ~/mytxt на root
	0.  (+) chown root:root ~/mytxt
	1.  (-) chmod root ~/mytxt
	2.  (-) chgrp root ~/mytxt
	3.  (-) chown root  ~/mytxt
74. [Практика (Linux)] Просмотрите руководство по команде more
	0.  (+) man more
	1.  (-) ruk more
	2.  (-) ls more
	3.  (-) cp more
75. [Практика (Linux)] Создайте жесткую ссылку для файла /home/user1/mytxt.txt с тем же именем, поместив ее в каталог /home/user1/work
	0.  (+) ln /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	1.  (-) ln -s /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	2.  (-) ln -h /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	3.  (-) ls /home/user1/mytxt.txt /home/user1/work/mytxt.txt
76. [Практика (Linux)] Создайте символьную ссылку для файла /home/user1/mytxt.txt с тем же именем, поместив ее в каталог /home/user1/work
	0.  (+) ln -s /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	1.  (-) ln -s mytxt.txt work/mytxt.txt
	2.  (-) link /home/user1/mytxt.txt /home/user1/work/mytxt.txt
	3.  (-) ls /home/user1/mytxt.txt /home/user1/work/mytxt.txt
77. [Практика (Linux)] Сравните файлы ls и ln, находящиеся в каталоге /bin, используя абсолютные имена файлов
	0.  (+) cmp /bin/ls /bin/ln
	1.  (-) cmp ./bin/ls ./bin/ln
	2.  (-) cmp ../bin/ls ../bin/ln
	3.  (-) cmp ~/bin/ls ~/bin/ln
78. [Практика (Linux)] Установите при помощи восьмеричных масок следующие права на файл ~/mytxt: для себя все права, для группы и остальных — никаких
	0.  (+) chmod 700 ~/mytxt
	1.  (-) chmod 500 ~/mytxt
	2.  (-) chmod 300 ~/mytxt
	3.  (-) chmod 100 ~/mytxt
79. [Практика (Linux)] Установите при помощи восьмеричных масок следующие права на файл ~/mytxt: для себя исполнение и запись, для группы никаких, для остальных чтение
	0.  (+) chmod 501 ~/mytxt
	1.  (-) chmod 701 ~/mytxt
	2.  (-) chmod 507 ~/mytxt
	3.  (-) chmod 505 ~/mytxt
80. [Практика (Linux)] Установите, используя символы прав доступа следующие права на файл ~/mytxt: для себя все права, для группы и остальных — никаких
	0.  (+) chmod u=rwx,go=  ~/mytxt
	1.  (-) chmod ugo=rwx  ~/mytxt
	2.  (-) chmod u=r,g=wx,o=  ~/mytxt
	3.  (-) chmod u=,go=rwx  ~/mytxt
81. [Практика (Linux)] Получите подробную информацию о файлах в текущем каталоге
	0.  (+) ls -la
	1.  (-) man cp
	2.  (-) ls -a
	3.  (-) cat
82. [Практика (Linux)] Получите список файлов текущего каталога, отсортированный по размеру
	0.  (+) ls -lS
	1.  (-) ls -la
	2.  (-) ls -l
	3.  (-) ls -a
83. [Практика (Linux)] Выведите на консоль имя самого большого (по размеру) файла текущего каталога
	0.  (+) ls -S | head -1
	1.  (-) head -1 | ls -S
	2.  (-) head -S
	3.  (-) head -l
84. [Практика (Linux)] Найдите все текстовые файлы (с расширением txt) текущего каталога, содержащие в названии "pro"
	0.  (+) find . -maxdepth 1 -name "*pro*.txt"
	1.  (-) find . -name "*pro*.txt"
	2.  (-) find -name "*pro*.txt"
	3.  (-) find . -maxdepth 1 -name "*pro*.doc"
85. [Практика (Linux)] Выведите список пользователей в алфавитном порядке
	0.  (+) cut -d: -f1 /etc/passwd
	1.  (-) cut -d; -f1 /etc/passwd
	2.  (-) cut -d: -f5 /etc/passwd
	3.  (-) cut -d: -f2 /home/passwd
86. [Практика (Linux)] Получите информацию о текущем пользователе
	0.  (+) cat /etc/passwd | grep `whoami`
	1.  (-) cat /passwd | grep `whoami`
	2.  (-) cat /etc/passwd | find `whoami`
	3.  (-) cat /passwd | find `whoami`
87. [Практика (Linux)] Установите при помощи восьмеричных масок следующие права на файл ~/mytxt: для себя исполнение и запись, для группы никаких, для остальных чтение.
	0.  (-) chmod 505 ~/mytxt
	1.  (-) chmod 504 ~/mytxt
	2.  (-) chmod 305 ~/mytxt
	3.  (+) chmod 304 ~/mytxt
88. [Синтаксический анализ] Деревом вывода грамматики G(T,N,P,S) называется дерево (граф), которое соответствует некоторой цепочке вывода и удовлетворяет следующим условиям:
	0.  (+) все перечисленное
	1.  (-) каждая вершина обозначается символом грамматики V in (T \cup N \cup {e})
	2.  (-) корнем дерева является вершина, обозначенная аксиомой S
	3.  (-) листьями являются вершины, обозначенные символом t in (T \cup {e})
89. [Синтаксический анализ] Детерминированный МПА
	0.  (+) может быть определен как семерка вида: P = (Q, Σ, Γ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет не более одного элемента
	1.  (-) может быть определен как семерка вида: P = (Q, Σ, Γ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет более одного элемента
	2.  (-) может быть определен как шестерка вида: P = (Q, Σ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет не более одного элемента
	3.  (-) может быть определен как пятерка вида: P = (Q, Σ, δ, q0, Z0), для функции переходов δ которой δ(q, a, X) имеет не более одного элемента
90. [Синтаксический анализ] Метод рекурсивного спуска применим к
	0.  (+) подклассу КС-грамматик
	1.  (-) подклассу КЗ-грамматик
	2.  (-) подклассу грамматик типа 0
	3.  (-) подклассу Р-грамматик
91. [Синтаксический анализ] МПА при построении синтаксического анализатора - это
	0.  (+) автомат с магазинной памятью
	1.  (-) межпроцессорный автомат
	2.  (-) мультипроцессорный автомат
	3.  (-) автомат на базе МП символики
92. [Синтаксический анализ] На этапе трансляции синтаксический анализ
	0.  (+) следует сразу после лексического анализа
	1.  (-) следует после семантического анализа
	2.  (-) выполняется последним
	3.  (-) выполняется первым
93. [Синтаксический анализ] Недетерминированный МПА
	0.  (+) может быть определен как семерка вида: P = (Q, Σ, Γ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет более одного элемента
	1.  (-) может быть определен как семерка вида: P = (Q, Σ, Γ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет не более одного элемента
	2.  (-) может быть определен как шестерка вида: P = (Q, Σ, δ, q0, Z0, F), для функции переходов δ которой δ(q, a, X) имеет более одного элемента
	3.  (-) может быть определен как пятерка вида: P = (Q, Σ, δ, q0, F), для функции переходов δ которой δ(q, a, X) имеет более одного элемента
94. [Синтаксический анализ] Одним из самых простых методов синтаксического анализа является
	0.  (+) метод рекурсивного спуска
	1.  (-) метод рекурсивного подъема
	2.  (-) метод градиентного спуска
	3.  (-) метод наискорейшего подъема
95. [Синтаксический анализ] Синтаксис языков программирования описывают с помощью
	0.  (+) контекстно-свободных грамматик
	1.  (-) контекстно-зависимых грамматик
	2.  (-) грамматик типа 0
	3.  (-) регулярных грамматик
96. [Синтаксический анализ] Синтаксический анализатор – это
	0.  (+) часть компилятора которая отвечает за выявление и проверку синтаксических конструкций входного языка
	1.  (-) слабоформализуемая часть трансляции, состоящая в жесткой проверке контекстных зависимостей
	2.  (-) часть компилятора, которая создает синтаксические конструкций входного языка
	3.  (-) часть компилятора, которая читает исходную программу и выделяет в ее тексте лексемы входного языка
97. [Синтаксический анализ] Характерной особенностью автомата с магазинной памятью является
	0.  (+) наличие дополнительной памяти в виде стека
	1.  (-) наличие дополнительной памяти в виде связного списка
	2.  (-) ограниченный объем ленты
	3.  (-) наличие управляющего устройства
98. [Синтаксический анализ] Что подается на вход синтаксического анализатора?
	0.  (+) сформированная ЛА таблица лексем
	1.  (-) таблица идентификаторов, сформированная ЛА
	2.  (-) все перечисленные варианты
	3.  (-) только код генерируемой программы
99. [Синтаксический анализ] В основе нисходящего синтаксического анализа
	0.  (+) Лежит левосторонний разбор
	1.  (-) Лежит правосторонний разбор
	2.  (-) Лежит параллельный разбор
	3.  (-) Лежит праворекурсивный разбор
100. [Синтаксический анализ] На основе какого синтаксического анализатора легче организовать процесс порождения цепочек результирующего языка?
	0.  (+) все варианты являются верными
	1.  (-) на основе левостороннего
	2.  (-) на основе нисходящего
	3.  (-) на основе анализатора, просматривающего входную цепочку символов слева направо
101. [Способы определения языка] Выберите действие, которое не выполняется распознавателем
	0.  (+) Удаление данных с ленты
	1.  (-) Анализ входного символа памяти и текущего состояния
	2.  (-) Перемещение при необходимости входной головки
	3.  (-) Чтение очередного символа с ленты
102. [Способы определения языка] К метасимволам языка РБНФ не относится
	0.  (+) «//»
	1.  (-) «[» и «]»
	2.  (-) «{» и «}»
	3.  (-) «|»
103. [Способы определения языка] К структурным компонентам распознавателя не относится
	0.  (+) Конфигурация
	1.  (-) Входная лента
	2.  (-) Входная головка
	3.  (-) Управляющее устройство
104. [Способы определения языка] Конфигурация распознавателя называется конечной, если
	0.  (+) управляющее устройство находится в заданном конечном состоянии, входная головка обозревает самый правый символ входной ленты и вспомогательная память имеет заранее установленное конечное состояние.
	1.  (-) управляющее устройство находится в заданном состоянии, входная головка обозревает самый левый символ на входной ленте и вспомогательная память имеет заранее установленное состояние.
	2.  (-) управляющее устройство находится в заданном конечном состоянии, входная головка обозревает самый левый символ ленты.
	3.  (-) управляющее устройство находится в заданном конечном состоянии.
105. [Способы определения языка] Конфигурация распознавателя называется начальной, если
	0.  (+) управляющее устройство находится в заданном начальном состоянии, входная головка обозревает самый левый символ на входной ленте и вспомогательная память имеет заранее установленное начальное состояние.
	1.  (-) управляющее устройство находится в заданном начальном состоянии, входная головка сошла с правого конца входной ленты.
	2.  (-) управляющее устройство находится в заданном начальном состоянии.
	3.  (-) управляющее устройство находится в заданном начальном состоянии, входная головка сошла с правого конца входной ленты и вспомогательная память имеет заранее установленное начальное состояние.
106. [Способы определения языка] По типу считывающего устройства распознаватели разделяются на
	0.  (+) односторониие и двусторонние
	1.  (-) детерминированные, недетерминированные
	2.  (-) без внешней памяти, с ограниченной внешней памятью, с неограниченной внешней памятью
	3.  (-) одноканальные, многоканальные
107. [Способы определения языка] Распознаватель – это
	0.  (+) специальный автомат который позволяет определить принадлежность цепочки символов некоторому языку
	1.  (-) специализированная программа, предназначенная для расшифровки текста
	2.  (-) последовательность ячеек, каждая из которых содержит один символ некоторого конечного входного алфавита
	3.  (-) специализированные устройства, которые вычленяют текст из графических файлов
108. [Способы определения языка] Управляющее устройство называется детерминированным, если
	0.  (+) Для каждой конфигурации распознавателя существует не более одного возможного следующего шага
	1.  (-) Для каждой конфигурации распознавателя существует более одного возможного следующего шага
	2.  (-) Для каждой конфигурации распознавателя существует ровно два возможных следующих шага
	3.  (-) Для любой конфигурации распознавателя не существует возможных следующих шагов
109. [Способы определения языка] Форма Бэкуса-Наура используется для
	0.  (+) описания контекстно-свободных формальных грамматик
	1.  (-) описания грамматик с фразовой структурой
	2.  (-) описания регулярных формальных грамматик
	3.  (-) описания контекстно-зависимых формальных грамматик
110. [Способы определения языка] Формальная грамматика определяется с помощью
	0.  (+) множества нетерминальных и терминальных символов, правил вывода и начального символа
	1.  (-) множества терминальных символов, правил вывода и начального символа
	2.  (-) множества нетерминальных символов, правил вывода и начального символа
	3.  (-) правил вывода и начального символа
111. [Способы определения языка] Язык, определяемый распознавателем, это
	0.  (+) множество всех цепочек, которые допускает распознаватель
	1.  (-) множество всех правил, которые реализуются распознавателем
	2.  (-) множество всех нетерминалов, которые допускаются распознавателем
	3.  (-) множество всех символов, которые допускает распознаватель
	4. [DISABLED] (-) множество цепочек, состоящих из нулей и единиц
	5. [DISABLED] (-) множество цепочек, состоящих из букв латинского алфавита
	6. [DISABLED] (-) правильных вариантов нет
112. [Способы определения языка] Возможность описания бесконечного множества цепочек языка с помощью конечного набора правил в форме Бекуса-Наура
	0.  (+) описания контекстно-свободных формальных грамматик
	1.  (-) описания регулярных формальных грамматик
	2.  (-) описания нерегулярных формальных грамматик
	3.  (-) описания контекстно-зависимых формальных грамматик
113. [Способы определения языка] Форма Бекуса-Наура используется для
	0.  (+) описания нерегулярных формальных грамматик
	1.  (-) описания регулярных формальных грамматик
	2.  (-) описания контекстно-свободных формальных грамматик
	3.  (-) описания контекстно-зависимых формальных грамматик
114. [Трансляция программ] gcc это
	0.  (+) компилятор
	1.  (-) сборщик мусора
	2.  (-) вторичный загрузчик
	3.  (-) транслятор ассемблера для linux
115. [Трансляция программ] python это
	0.  (+) интерпретатор
	1.  (-) компилятор
	2.  (-) программатор
	3.  (-) ретранслятор
116. [Трансляция программ] Ассемблер - это частный случай
	0.  (+) компилятора
	1.  (-) интерпретатора
	2.  (-) компоновщика
	3.  (-) отладчика
117. [Трансляция программ] Для того, чтобы выполнить программу, необходимо
	0.  (+) Разместить ее в памяти компьютера.
	1.  (-) Записать ее в MBR.
	2.  (-) Сгенерировать объектный файл.
	3.  (-) Перевести программу на язык ассемблера.
118. [Трансляция программ] Интерпретатор это
	0.  (+) программа, которая воспринимает входную программу на исходном языке и выполняет ее.
	1.  (-) программа, которая переводит входную программу на исходном языке в эквивалентную ей выходную программу на результирующем языке.
	2.  (-) это транслятор, который осуществляет перевод исходной программы в эквивалентную ей объектную программу на языке машинных команд или языке ассемблера.
	3.  (-) программа, которая воспринимает входную программу на исходном языке и передает сформированный машинный код компилятору.
119. [Трансляция программ] Исходный код это
	0.  (+) язык, на котором представлена входная программа
	1.  (-) результат последнего этапа трансляции
	2.  (-) последовательность байт-кода из которого компилируется машинный код
	3.  (-) язык описания алгоритмов использующий ключевые слова языков программирования, но опускающий подробности и специфический синтаксис
120. [Трансляция программ] К общим синтаксическим критериям не относится
	0.  (+) Малое потребление ресурсов
	1.  (-) Легкость чтения
	2.  (-) Легкость написания
	3.  (-) Простота верификации
121. [Трансляция программ] Какое утверждение является верным (вопрос об отношении между компилятором, транслятором и интерпретатором)
	0.  (+) Компилятор - частный случай транслятора
	1.  (-) Транслятор - частный случай компилятора
	2.  (-) Интерпретатор - частный случай компилятора
	3.  (-) Компилятор - частный случай интерпретатора
122. [Трансляция программ] Какое утверждение является неверным (вопрос об отношении между компилятором, транслятором и интерпретатором)
	0.  (+) Интерпретатор - частный случай компилятора
	1.  (-) Компилятор - частный случай транслятора
	2.  (-) Асемблер - частный случай транслятора
	3.  (-) Интерпретатор - частный случай транслятора
123. [Трансляция программ] Компиляция это
	0.  (+) трансляция исходного кода в машинный
	1.  (-) трансляция ассемблерного кода в машинный
	2.  (-) трансляция исходного кода в ассемблер
	3.  (-) трансляция машинного кода в ассемблерный
124. [Трансляция программ] На последнем этапе трансляции исходный код превращается в
	0.  (+) исполняемый файл
	1.  (-) объектный файл
	2.  (-) байт-код
	3.  (-) код на языке ассемблера
125. [Трансляция программ] Необязательным этапом трансляции программы является
	0.  (+) оптимизация
	1.  (-) лексический анализ
	2.  (-) компоновка
	3.  (-) семантический анализ
126. [Трансляция программ] Программа, которая собирает исполняемый файл из нескольких объектных модулей, называется
	0.  (+) Компоновщик
	1.  (-) Компилятор
	2.  (-) Препроцессор
	3.  (-) Динамический компилятор
127. [Трансляция программ] Программа, позволяющая управлять процессом выполнения программы и обнаруживать в ней ошибки
	0.  (+) отладчик
	1.  (-) компоновщик
	2.  (-) компилятор
	3.  (-) загрузчик
128. [Трансляция программ] Что из перечисленного не является этапом трансляции программы
	0.  (+) Морфологический анализ
	1.  (-) Семантический анализ
	2.  (-) Синтаксический анализ
	3.  (-) Лексический анализ
129. [Трансляция программ] Что такое препроцессор
	0.  (+) транслятор с одного языка программирования в другой без создания исполняемого файла или выполнения программы
	1.  (-) первый этап трансляции
	2.  (-) это транслятор для интерпретируемых языков программирования
	3.  (-) инструкция, которая подается в материанскую плату для инициализации работы процессора
130. [Трансляция программ] К функциям семантического анализатора не относится
	0.  (-) поддержка таблицы символов
	1.  (-) обнаружение ошибок
	2.  (-) макрообработка
	3.  (+) раскрутка
131. [Формальные языки и грамматики (определения)] Алфавит в формальных языках – это
	0.  (+) счетное множество допустимых символов языка
	1.  (-) простой, неделимый знак
	2.  (-) произвольная, упорядоченная конечная последовательность знаков алфавита
	3.  (-) звуковое, буквенное выражение закодированной информации
132. [Формальные языки и грамматики (определения)] В формальных языках и грамматиках цепочка ω называется подцепочкой γ, если γ=
	0.  (+) αωβ
	1.  (-) γ(ω)
	2.  (-) ω(γ)
	3.  (-) αγβ
133. [Формальные языки и грамматики (определения)] В формальных языках лексема это -
	0.  (+) конструкция которая состоит из элементов алфавита языка и не содержит в себе других конструкций
	1.  (-) совокупность слов, словарный запас языка
	2.  (-) набор правил, определяющий допустимые конструкции языка, т.е. задает набор цепочек символов, которые принадлежат языку
	3.  (-) раздел языка, определяющий значение предложений языка, т.е. задает смысл всех допустимых цепочек языка
134. [Формальные языки и грамматики (определения)] В формальных языках лексика это -
	0.  (+) совокупность слов (словарный запас) языка
	1.  (-) конструкция, которая состоит из элементов алфавита языка и не содержит в себе других конструкций
	2.  (-) набор правил, определяющий допустимые конструкции языка, т.е. задает набор цепочек символов, которые принадлежат языку
	3.  (-) раздел языка, определяющий значение предложений языка, т.е. задает смысл всех допустимых цепочек языка
135. [Формальные языки и грамматики (определения)] В формальных языках семантика это -
	0.  (+) раздел языка, определяющий значение предложений языка, т.е. задает смысл всех допустимых цепочек языка
	1.  (-) совокупность слов, словарный запас языка
	2.  (-) конструкция, которая состоит из элементов алфавита языка и не содержит в себе других конструкций
	3.  (-) набор правил, определяющий допустимые конструкции языка, т.е. задает набор цепочек символов, которые принадлежат языку
136. [Формальные языки и грамматики (определения)] В формальных языках синтаксис это -
	0.  (+) набор правил, определяющий допустимые конструкции языка, т.е. задает набор цепочек символов, которые принадлежат языку
	1.  (-) совокупность слов, словарный запас языка
	2.  (-) конструкция, которая состоит из элементов алфавита языка и не содержит в себе других конструкций
	3.  (-) раздел языка, определяющий значение предложений языка, т.е. задает смысл всех допустимых цепочек языка
137. [Формальные языки и грамматики (определения)] Все существующие формальные языки строятся на основе
	0.  (+) различных конечных алфавитов
	1.  (-) бесконечных алфавитов
	2.  (-) беззнаковых алфавитах
	3.  (-) кодировкой Unicode
138. [Формальные языки и грамматики (определения)] Для задания ЯП необходимо
	0.  (+) все ответы правильные
	1.  (-) определить множество допустимых символов языка
	2.  (-) определить множество правильных программ языка
	3.  (-) задать смысл для каждой правильной программы
139. [Формальные языки и грамматики (определения)] Какая из проблем не решается в теории формальных языков
	0.  (+) задать смысл для каждой правильной программы
	1.  (-) определить множество правильных программ языка
	2.  (-) определить множество допустимых символов языка
	3.  (-) в теории формальных языков нет нерешаемых проблем
140. [Формальные языки и грамматики (определения)] Символ (буква) в формальных языках – это
	0.  (+) простой, неделимый знак
	1.  (-) счетное множество допустимых символов языка
	2.  (-) произвольная упорядоченная конечная последовательность знаков алфавита
	3.  (-) конечный результат любой закодированной информации
141. [Формальные языки и грамматики (определения)] Слова в формальных языках - это
	0.  (+) все последовательности терминалов, выводимые (порождаемые) из начального нетерминала по правилам вывода, заданного грамматикой
	1.  (-) счетное множество допустимых символов языка
	2.  (-) произвольная упорядоченная конечная последовательность знаков алфавита
	3.  (-) конечный результат любой закодированной информации
142. [Формальные языки и грамматики (определения)] Формальная грамматика - это
	0.  (+) способ описания формального языка, выделение некоторого подмножества из множества всех слов некоторого конечного алфавита
	1.  (-) множество атомарных (неделимых) символов какого-либо формального языка
	2.  (-) условно верное написание формальных символов
	3.  (-) подвид грамматик Хомского
143. [Формальные языки и грамматики (определения)] Цепочка символов (строка) - это
	0.  (+) произвольная, упорядоченная конечная последовательность знаков алфавита
	1.  (-) простой неделимый знак
	2.  (-) счетное множество допустимых символов языка
	3.  (-) цепочка символов представленная в определенной последовательности
144. [Формальные языки и грамматики (определения)] Что можно описать в виде строгого набора правил?
	0.  (+) только формальные языки.
	1.  (-) только неформальные языки
	2.  (-) формальные и неформальные языки
	3.  (-) почти все ЯП
145. [Формальные языки и грамматики (определения)] Что такое грамматика
	0.  (+) Наука изучающая способ построения языка
	1.  (-) Наука, изучающая смысловое значение единиц языка
	2.  (-) Наука, изучающая морфологические модели языка
	3.  (-) Наука, изучающая множество лексем
146. [Формальные языки и грамматики (определения)] Язык L над алфавитом А – это
	0.  (+) подмножество цепочек А*
	1.  (-) подмножество цепочек А
	2.  (-) подмножество цепочек L
	3.  (-) подмножество цепочек L*
147. [Формальные языки и грамматики (определения)] Язык L над алфавитом А: L(A) это некоторое счетное подмножество цепочек конечной длины из множества всех цепочек алфавита А: (in — является подмножеством)
	0.  (+) L(A) in А*
	1.  (-) А* in L(A)
	2.  (-) L(A) in А
	3.  (-) A(L) in L
148. [Формальные языки и грамматики (определения)] Алфавит формального языка - это
	0.  (+) множество атомарных (неделимых) символов какого-либо формального языка
	1.  (-) способ описания формального языка и выделение некоторого подмножества из множества всех слов некоторого конечного алфавита
	2.  (-) форма письменности основанная на нестандартном наборе знаков
	3.  (-) подвид языков Хомского
149. [Оконные приложения] Выберите неверное утверждение о синхронных сообщениях в ОС Windows
	0.  (+) Сообщения ставятся в очередь синхронных сообщений вызовом функции PostQuitMessage
	1.  (-) Возврат к вызывающему коду происходит только после окончания обработки сообщения оконной процедурой
	2.  (-) Синхронное сообщение можно передать другому потоку, включив в его очередь сообщений и установив флаг QS_SENDMESSAGE
	3.  (-) Синхронное сообщение можно отправить вызовом функции SendMessage
150. [Оконные приложения] Выберите неверное утверждение об асинхронных сообщениях в ОС Windows
	0.  (+) Возврат к вызывающему коду происходит только после окончания обработки сообщения оконной процедурой
	1.  (-) Сообщения ставятся в очередь асинхронных сообщений вызовом функции PostMessage
	2.  (-) Возврат к вызывающему коду происходит сразу после того, как сообщение поставлено в очередь
	3.  (-) Окно может не получить асинхронное сообщение
151. [Оконные приложения] Для инициации механизма перерисовки окна в Windows-приложениях нужно вызвать функцию
	0.  (+) InvalidateRect
	1.  (-) UpdateWindow
	2.  (-) BeginPaint
	3.  (-) EndPaint
152. [Оконные приложения] Загрузка ресурса из внешнего исполняемого файла для Windows-приложений выполняется с помощью функции
	0.  (+) LoadResource
	1.  (-) LoadLibrary
	2.  (-) LoadModule
	3.  (-) FindResource
153. [Оконные приложения] К стандартным видам ресурсов Windows-программ не относится
	0.  (+) Bitmap Table
	1.  (-) Menu
	2.  (-) Icon
	3.  (-) Font
154. [Оконные приложения] К типам оконных сообщений Windows не относится
	0.  (+) WM_CLICK
	1.  (-) WM_DESTROY
	2.  (-) WM_MOVE
	3.  (-) WM_CLOSE
155. [Оконные приложения] Какая структура данных используется для хранения оконных сообщений?
	0.  (+) Очередь
	1.  (-) Стек
	2.  (-) Список
	3.  (-) Массив
156. [Оконные приложения] Назначение оконной функции — это
	0.  (+) Обработка событий для этого окна
	1.  (-) Конструирование и инстанцирование класса окна
	2.  (-) Прорисовка окна
	3.  (-) Правильного варианта нет
157. [Оконные приложения] Прием сообщений в главном цикле обработки сообщений в программах ОС Windows осуществляет функция
	0.  (+) GetMessage
	1.  (-) TranslateMessage
	2.  (-) DispatchMessage
	3.  (-) RecordMessage
158. [Оконные приложения] Точкой входа в Windows-приложение является функция
	0.  (+) WinMain
	1.  (-) main
	2.  (-) winMain
	3.  (-) Main
159. [Оконные приложения] Тип HINSTANCE представляет
	0.  (-) Дескриптор окна
	1.  (-) Дескриптор ресурса
	2.  (+) Дескриптор приложения
	3.  (-) Дескриптор формы
160. [Оконные приложения] Тип HWND представляет
	0.  (-) Дескриптор драйвера
	1.  (+) Дескриптор окна
	2.  (-) Дескриптор дескриптора
	3.  (-) Дескриптор ресурса
161. [Процессы Windows] К состояниям процесса не относится
	0.  (+) Переключение контекста
	1.  (-) Готовности к запуску
	2.  (-) Выполнения
	3.  (-) Ожидания
162. [Процессы Windows] Каждый процесс имеет как минимум один
	0.  (+) Поток
	1.  (-) Идентификатор
	2.  (-) Файловый дескриптор
	3.  (-) Приоритет
163. [Процессы Windows] Критическая секция - это объект синхронизации
	0.  (+) представляющий собой участок исполняемого кода программы, в котором производится доступ к общему ресурсу и который не может быть выполнен более чем одним потоком выполнения
	1.  (-) используемый для обеспечения монопольного доступа к некоторому ресурсу со стороны нескольких потоков
	2.  (-) применяемый для учета использования ресурсов
	3.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
164. [Процессы Windows] Мьютекс — это объект синхронизации
	0.  (+) используемый для обеспечения монопольного доступа к некоторому ресурсу со стороны нескольких потоков
	1.  (-) применяемый для учета использования ресурсов
	2.  (-) который применяется для уведомления потоков об окончании какой-либо операции.
	3.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
165. [Процессы Windows] Переключение контекста происходит при
	0.  (+) Изменении выполняющегося в настоящий момент процесса
	1.  (-) Изменении активного потока
	2.  (-) Изменении активного ядра процессора
	3.  (-) Смене фокуса в оконном приложении
166. [Процессы Windows] Семафор — это объект синхронизации
	0.  (+) в основе которого лежит счетчик разрешений для доступа потоков к общему ресурсу
	1.  (-) который применяется для уведомления потоков об окончании какой-либо операции.
	2.  (-) представляющий собой участок исполняемого кода программы, в котором производится доступ к общему ресурсу и который не может быть выполнен более чем одним потоком выполнения
	3.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
167. [Процессы Windows] Событие — это объект синхронизации
	0.  (+) который используется для того, чтобы сигнализировать другим потокам о наступлении чего-либо
	1.  (-) используемый для обеспечения монопольного доступа к некоторому ресурсу со стороны нескольких потоков
	2.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
	3.  (-) применяемый для учета использования ресурсов
168. [Процессы Windows] Состояние взаимоблокировки возникает
	0.  (+) При ожидании процессами ресурсов, захваченных друг другом
	1.  (-) При ошибке проектирования многопоточной системы, выражающейся в зависимости от порядка выполнения кода
	2.  (-) При исключительной ситуации
	3.  (-) При аппаратном прерывании
169. [Процессы Windows] Состояние гонки возникает
	0.  (+) При ошибке проектирования многопоточной системы, выражающейся в зависимости от порядка выполнения кода
	1.  (-) При ожидании процессами ресурсов, захваченных друг другом
	2.  (-) Как ответная реакция процессора на некорректную операцию ввода-вывода
	3.  (-) Ответная реакция системы на отсутствие страницы памяти
170. [Процессы Windows] File mapping — это
	0.  (+) Механизм отображения содержимого файла в виртуальное адресное пространство процесса
	1.  (-) Конвеер для преобразования файла
	2.  (-) Механизм отображения содержимого файла в оперативную память
	3.  (-) Часть виртуального адресного пространства процесса, которую он использует для доступа к файлу
171. [Процессы Windows] PCB расшифровывается как
	0.  (+) Process control block
	1.  (-) Printed circuit board
	2.  (-) Polychlorinated biphenyl
	3.  (-) Police Complaints Board
172. [Процессы Windows] Именованный канал — это объект синхронизации
	0.  (+) являющийся средством межпроцессной коммуникации
	1.  (-) который используется для того, чтобы сигнализировать другим потокам о наступлении чего-либо
	2.  (-) самостоятельно переходящий в свободное состояние в определенное время и/или через определенные промежутки времени
	3.  (-) применяемый для учета использования ресурсов
173. [Процессы Windows] Каждый процесс представляется в ОС в виде
	0.  (+) PCB
	1.  (-) IRP
	2.  (-) ARP
	3.  (-) ISR
174. [Процессы Windows] Очередь готовности — это
	0.  (+) очередь процессов, размещенных в памяти и ожидающих выполнения
	1.  (-) очередь процессов, завершивших свое выполнения и ожидающих выгрузки из памяти
	2.  (-) очередь процессов, ожидающих освобождения устройства ввода-вывода
	3.  (-) Правильного варианта нет
175. [Процессы Windows] Очередь устройств — это
	0.  (+) очередь процессов, ожидающих освобождения устройства ввода-вывода
	1.  (-) очередь процессов, размещенных в памяти и ожидающих выполнения
	2.  (-) Очередь физических устройств, ожидающих инициализации драйверов
	3.  (-) Правильного варианта нет
176. [Процессы Windows] Представить планирование выполнения процессов в системе можно с помощью
	0.  (+) Диаграммы очередей
	1.  (-) Диаграммы стеков
	2.  (-) Схемы распределения
	3.  (-) Очереди готовности
177. [Процессы Windows] Представление файла (file view) — это
	0.  (+) Часть виртуального адресного пространства процесса, которую он использует для доступа к файлу
	1.  (-) Превдоним имени файла
	2.  (-) Отображение файла в оперативную память
	3.  (-) Его расширение
178. [Процессы Windows] Разделение памяти в ОС Windows позволяет
	0.  (+) Осуществлять межпроцессное взаимодействие
	1.  (-) Осуществить копирование файлов
	2.  (-) Осуществить передачу данных по сети
	3.  (-) Осуществить подключение к удаленному рабочему столу
179. [Процессы Windows] Создание разделяемой памяти начинается с вызова функции
	0.  (+) CreateFileMapping
	1.  (-) MapViewOfFile
	2.  (-) CopyMemory
	3.  (-) CloseHandle
180. [Процессы Windows] Технология processor affinity позволяет
	0.  (+) осуществлять закрепление и открепление процесса или потока к конкретному процессорному устройству
	1.  (-) осуществлять согласованную работу процессора с несколькими ядрами
	2.  (-) осуществлять переключение процессора на выполнение различных процессов
	3.  (-) осуществлять работу процессора в неблокирующем режиме
181. [Процессы Windows] Процесс в WinAPI создается функцией
	0.  (-) StartProcess
	1.  (-) ConstructProcess
	2.  (-) BuildProcess
	3.  (+) CreateProcess
182. [Прерывания] Cпециальная процедура, вызываемая по прерыванию для выполнения его обработки
	0.  (+) ISR
	1.  (-) APC
	2.  (-) DPC
	3.  (-) IoGetCurrentIrpStackLocation
183. [Прерывания] DIRQL — это
	0.  (+) Диапазон уровней прерываний устройств
	1.  (-) Уровень отложенного вызова процедур
	2.  (-) Уровень асинхронного вызова процедур
	3.  (-) Уровень для управления системными часами
184. [Прерывания] IRQL — это
	0.  (+) Уровни прерываний
	1.  (-) Уровни исключений
	2.  (-) Процедура обработки прерываний
	3.  (-) Правильного варианта нет
185. [Прерывания] В ОС семества Windows NT x86 количество уровней прерываний равно
	0.  (+) 32
	1.  (-) 64
	2.  (-) 16
	3.  (-) 8
186. [Прерывания] В ОС семества Windows NT х64 и IA64 количество уровней прерываний равно
	0.  (+) 16
	1.  (-) 32
	2.  (-) 64
	3.  (-) 8
187. [Прерывания] Для выполнения APC пользовательского режима в контексте целевого потока
	0.  (+) Разрешение целевого потока требуется
	1.  (-) Разрешение целевого потока не требуется
	2.  (-) Разрешение целевого потока не требуется, но желательно
	3.  (-) Правильного варианта нет
188. [Прерывания] Для выполнения APC режима ядра в контексте целевого потока
	0.  (+) Разрешение целевого потока не требуется
	1.  (-) Разрешение целевого потока требуется
	2.  (-) Разрешение целевого потока не требуется, но желательно
	3.  (-) Правильного варианта нет
189. [Прерывания] Для поиска обработчика прерываний в Windows используется таблица
	0.  (+) IDT
	1.  (-) MDL
	2.  (-) SST
	3.  (-) GDT
190. [Прерывания] К возникновению исключения не приводит
	0.  (+) подключение флешки
	1.  (-) ошибка деления на ноль
	2.  (-) нарушение защиты памяти
	3.  (-) некоторые отладочные команды
191. [Прерывания] Прерывания, поступающие от источника с IRQL, превышающим текущий уровень…
	0.  (+) прерывают работу процессора и обрабатываются
	1.  (-) маскируются до тех пор, пока выполняющийся поток не понизит IRQL
	2.  (-) игнорируются и пропускаются
	3.  (-) не происходят
192. [Прерывания] Прерывания, поступающие от источников с IRQL, равными или ниже текущего уровня…
	0.  (+) маскируются до тех пор, пока выполняющийся поток не понизит IRQL
	1.  (-) прерывают работу процессора и обрабатываются
	2.  (-) игнорируются и пропускаются
	3.  (-) не происходят
193. [Прерывания] При DPC-вызове передача управления вызываемой процедуре
	0.  (+) не происходит сразу, а откладывается
	1.  (-) происходит сразу же
	2.  (-) не происходит
	3.  (-) происходит по таймеру
194. [Прерывания] Уровень IRQL с самым высоким приоритетом – это
	0.  (+) High
	1.  (-) PASSIVE
	2.  (-) DPC
	3.  (-) DIRQL
195. [Прерывания] Уровень IRQL с самым низким приоритетом – это
	0.  (+) PASSIVE
	1.  (-) IPI
	2.  (-) Profile
	3.  (-) DPC/DISPATCH
196. [Прерывания] Этот уровень IRQL используется при взаимодействии процессоров и запроса на выполнение какой-то операции
	0.  (+) IPI
	1.  (-) High
	2.  (-) Clock
	3.  (-) DPC
197. [Архитектура Windows] Большинство внутренних текстовых строк в Windows хранится в кодировке
	0.  (+) UTF16
	1.  (-) UTF8
	2.  (-) UTF32
	3.  (-) ANSI
198. [Архитектура Windows] Венгерская нотация — соглашение об именовании переменных, суть которого сводится к тому, что
	0.  (+) имена идентификаторов предваряются заранее оговорёнными префиксами, состоящими из одного или нескольких символов
	1.  (-) в именах идентификаторов опускаются гласные буквы
	2.  (-) имена идентификаторов завершаются заранее оговоренными суффиксами, состоящими из одного или нескольких символов
	3.  (-) имена идентификаторов всегда записываются, начиная с прописной буквы
199. [Архитектура Windows] Ветвь HKEY_CURRENT_USER реестра хранит сведения о
	0.  (+) Настройках персональной оболочки пользователя, совершающего вход в операционную систему (меню «Пуск», рабочий стол и т. д.)
	1.  (-) Настройках Windows для всех пользователей
	2.  (-) Расширениях всех зарегистрированных в системе типов файлов и данные о COM-серверах, зарегистрированных на компьютере
	3.  (-) Состоянии устройств, установленных на компьютере
200. [Архитектура Windows] Ветвь HKEY_LOCAL_MACHINE реестра хранит сведения о
	0.  (+) Операционной системе и оборудовании, сведения о загрузке Windows
	1.  (-) Расширениях всех зарегистрированных в системе файлов и данные о COM-серверах
	2.  (-) Профилях всех пользователей данного компьютера
	3.  (-) Профилях оборудования, использующегося в данном сеансе работы
201. [Архитектура Windows] Для закрытия объектов ядра Windows применяют функцию
	0.  (+) CloseHandle
	1.  (-) Close
	2.  (-) FreeLibrary
	3.  (-) CloseKernelObject
202. [Архитектура Windows] Для описания дескриптора объекта в Windows API используется тип
	0.  (+) HANDLE
	1.  (-) BOOL
	2.  (-) DWORD
	3.  (-) LPSECURITY_ATTRIBUTES
203. [Архитектура Windows] Загружаемый модуль режима ядра, предоставляющий низкоуровневый интерфейс для аппаратной платформы, на которой выполняется Windows
	0.  (+) HAL
	1.  (-) DAL
	2.  (-) DDK
	3.  (-) VMS
204. [Архитектура Windows] К DLL подсистемы Windows не относится
	0.  (+) Psxdll.dll
	1.  (-) Kernel32.dll
	2.  (-) Advapi32.dll
	3.  (-) User32.dll
205. [Архитектура Windows] К ветвям реестра Windows-систем не относится
	0.  (+) HKEY_USER
	1.  (-) HKEY_CLASSES_ROOT
	2.  (-) HKEY_LOCAL_MACHINE
	3.  (-) HKEY_CURRENT_CONFIG
206. [Архитектура Windows] К исполнительной системе Windows не относится
	0.  (+) Служба сервера
	1.  (-) Диспетчер кэша
	2.  (-) Монитор безопасности
	3.  (-) Диспетчер электропитания
207. [Архитектура Windows] К объектам ядра не относится
	0.  (+) Критические разделы
	1.  (-) Маркеры доступа
	2.  (-) Проекции файлов
	3.  (-) Процессы
208. [Архитектура Windows] К системным процессам Windows не относится
	0.  (+) Winword.exe
	1.  (-) Smss.exe
	2.  (-) Winlogon.exe
	3.  (-) Svchost.exe
209. [Архитектура Windows] Ядро ОС Windows находится в файле
	0.  (+) Ntoskrnl.exe
	1.  (-) Kernel32.dll
	2.  (-) Ntdll.dll
	3.  (-) Ntkrnlmp.exe
210. [Архитектура Windows] Гипервизор - это
	0.  (-) это процесс, контролирующий выполнение других процессов в ОС
	1.  (-) это процесс, контролирующий взаимодействие программного и аппаратного обеспечение вычислительной машины
	2.  (+) это процесс, обеспечивающий создание и выполнение виртуальных машин
	3.  (-) это процесс, обеспечивающий маршрутизацию пакетов в сетях передачи данных
211. [Драйверы] DPC-точка входа драйвера нужна для
	0.  (+) Завершения работы, которая должна быть сделана в результате появления прерывания
	1.  (-) Обработки аппаратных прерываний от нижележащих устройств
	2.  (-) Вызова кода, когда истекает время запрошенного таймера
	3.  (-) Выполнения некоторых действий при выгрузке драйвера
212. [Драйверы] DriverEntry — это
	0.  (+) Процедура инициализации Windows-драйвера
	1.  (-) Процедура добавления устройства
	2.  (-) Процедура начала ввода-вывода
	3.  (-) Процедура обработки прерываний
213. [Драйверы] DriverEntry вызывается на IRQL равном
	0.  (+) PASSIVE_LEVEL
	1.  (-) APC_LEVEL
	2.  (-) DISPATCH_LEVEL
	3.  (-) на одном из DIRQL
214. [Драйверы] ISR-точка входа драйвера нужна для
	0.  (+) Обработки прерываний
	1.  (-) Завершения ввода-вывода
	2.  (-) Выгрузки драйвера
	3.  (-) Инициализации драйвера
215. [Драйверы] WDM — это
	0.  (+) Windows driver model
	1.  (-) Wavelength Division Multiplexing
	2.  (-) WINgs Display Manager
	3.  (-) Windows Display Monitor
216. [Драйверы] Драйвер NT располагается в файле с расширением
	0.  (+) sys
	1.  (-) so
	2.  (-) drv
	3.  (-) dll
217. [Драйверы] Драйверы PnP должны реализовывать эту процедуру
	0.  (+) процедура добавления устройства
	1.  (-) Процедура выгрузки
	2.  (-) процедура регистрации ошибок
	3.  (-) процедура отмены ввода -вывода
218. [Драйверы] Драйверы, управляющие устройствами конкретного типа
	0.  (+) Функциональные драйверы
	1.  (-) Драйверы шины
	2.  (-) Фильтрующие драйверы
	3.  (-) Драйверы файловой системы
219. [Драйверы] Какая процедура драйвера выполняет основную часть обработки прерывания, оставшейся после вызова ISR-процедуры
	0.  (+) DPC-процедура
	1.  (-) Процедура завершения ввода-вывода
	2.  (-) Процедура отмены ввода вывода
	3.  (-) Процедура обработки прерываний
220. [Драйверы] После удаления последнего объекта устройства и отсутствии ссылок на драйвер диспетчер ввода-вывода производит
	0.  (+) выгрузку этого драйвера
	1.  (-) повторную инициализацию этого драйвера
	2.  (-) замену этого драйвера
	3.  (-) удаление этого драйвера
221. [Драйверы] С какой компонентой исполнительной системы Windows чаще всего взаимодействует драйвер
	0.  (+) Диспетчер ввода-вывода
	1.  (-) Монитор безопасности
	2.  (-) Диспетчер кэша
	3.  (-) Диспетчер процессов
222. [Драйверы] Фильтрующие драйверы нужны для
	0.  (+) Исправления ошибок в существующих драйверах и их расширения
	1.  (-) Для управления устройствами конкретного типа
	2.  (-) Для осуществления взаимодействия между устройствами
	3.  (-) Для отслеживания устройств, подключаемых к системе
223. [Динамические библиотеки] Динамическая библиотека содержит
	0.  (+) Машинный код
	1.  (-) Байт-код
	2.  (-) Гибридный код
	3.  (-) Обычный код программы который подгружается динамически при необходимости
224. [Динамические библиотеки] Для загрузки DLL-библиотеки в память не применяют функцию
	0.  (+) GetProcAddress
	1.  (-) LoadLibrary
	2.  (-) LoadLibraryEx
	3.  (-) GetModuleHandle
225. [Динамические библиотеки] Для указания импортируемых из DLL функций применяют конструкцию
	0.  (+) __declspec( dllimport )
	1.  (-) declspec( dllimport )
	2.  (-) __declspec( import )
	3.  (-) declspec( import )
226. [Динамические библиотеки] Для указания экспортируемых из DLL функций применяют конструкцию
	0.  (+) __declspec( dllexport )
	1.  (-) declspec( dllexport )
	2.  (-) __declspec( export )
	3.  (-) declspec( export )
227. [Динамические библиотеки] Изменение динамической библиотеки, влияет на программы которые ее используют?
	0.  (+) Влияет, на все работающие программы
	1.  (-) Изменит поведение всех програм, которые компилировались после изменения библиотеки
	2.  (-) Изменит только поведение программ на этапе компоновки которых был сгенерирован байт-код
	3.  (-) Никак не влияет
228. [Динамические библиотеки] Код статической библиотеки
	0.  (+) Включается в исполняемый файл
	1.  (-) Включается в исполняемый файл при необходимости
	2.  (-) Включается только ссылка на библиотеку
	3.  (-) Вообще не включается в исполняемый файл
229. [Динамические библиотеки] Отличительный признак динамической библиотеки
	0.  (+) Одна копия может использоваться несколькими процессами
	1.  (-) Динамически вставляется в программу на этапе компоновки
	2.  (-) Содержит байт-код для виртуальной машины
	3.  (-) Одна библиотека может использоваться только одним процессом
230. [Динамические библиотеки] При загрузке DLL c неявной компоновкой
	0.  (+) Необходимо наличие lib-файла
	1.  (-) Необходимо настроить указатель на функцию, включенную в DLL, для доступа к ней
	2.  (-) Необходимо явно загрузить библиотеку
	3.  (-) Необходимо явно выгрузить библиотеку
231. [Динамические библиотеки] При загрузке DLL c явной компоновкой
	0.  (+) Необходимо настроить указатель на функцию, включенную в DLL, для доступа к ней
	1.  (-) Необходимо наличие lib-файла
	2.  (-) Обращение к функциям DLL выполняется так же, как и к локальным функциям
	3.  (-) Загрузка DLL осуществляется одновременно с загрузкой исполняемого файла, который ее использует
232. [Динамические библиотеки] При использовании статической библиотеки
	0.  (+) Программа компилируется один раз и может запускаться на любом компьютере без дополнительных библиотек
	1.  (-) Программа будет запускаться, если в системе присутствует эта статическая библиотека
	2.  (-) Программа будет запускаться только при использовании виртуальной машины
	3.  (-) Статические библиотеки используются только интерпретируемыми программами, т.е. программа будет запускаться на любом компьютере
233. [Динамические библиотеки] При нормальном завершении потока в процессе, система для всех спроецированных в адресное пространство DLL вызывает функцию DllMain с параметром fdwReason равным
	0.  (+) DLL_THREAD_DETACH
	1.  (-) DLL_THREAD_ATTACH
	2.  (-) DLL_PROCESS_DETACH
	3.  (-) DLL_THREADS_DETACH
234. [Динамические библиотеки] При отключении DLL от адресного пространства процесса вызывается ее функция DllMain со значением параметра fdwReason равным
	0.  (+) DLL_PROCESS_DETACH
	1.  (-) DLL_PROCESS_ATTACH
	2.  (-) DLL_THREAD_DETACH
	3.  (-) DLL_THREADS_DETACH
235. [Динамические библиотеки] При проецировании DLL в адресное пространство процесса первый раз система вызывает DllMain со значением параметра fdwReason равным
	0.  (+) DLL_PROCESS_ATTACH
	1.  (-) DLL_PROCESS_DETACH
	2.  (-) DLL_THREADS_ATTACH
	3.  (-) DLL_THREAD_DETACH
236. [Динамические библиотеки] При создании нового потока в процессе, система для всех спроецированных в адресное пространство DLL вызывает функцию DllMain с параметром fdwReason равным
	0.  (+) DLL_THREAD_ATTACH
	1.  (-) DLL_PROCESS_ATTACH
	2.  (-) DLL_PROCESSES_ATTACH
	3.  (-) DLL_THREADS_ATTACH
237. [Динамические библиотеки] Процесс может использовать функции динамической библиотеки
	0.  (+) Если она загружена в память
	1.  (-) Если она загружена в память и ее функции не использует другой процесс
	2.  (-) Если она была включена в его код на этапе компоновки
	3.  (-) Непосредственно, без загрузки
238. [Динамические библиотеки] Расширение динамических библиотек в Linux
	0.  (+) so
	1.  (-) dll
	2.  (-) lib
	3.  (-) dlib
239. [Динамические библиотеки] Расширение динамических библиотек в Windows
	0.  (+) dll
	1.  (-) so
	2.  (-) lib
	3.  (-) a
240. [Динамические библиотеки] Расширение статических библиотек в Linux
	0.  (+) a
	1.  (-) lib
	2.  (-) so
	3.  (-) dll
241. [Динамические библиотеки] Расширение статических библиотек в Windows
	0.  (+) lib
	1.  (-) dll
	2.  (-) obj
	3.  (-) stat
242. [Динамические библиотеки] Функция входа в DLL — это функция
	0.  (+) DllMain
	1.  (-) MainDll
	2.  (-) dllMain
	3.  (-) Main
243. [Динамические библиотеки] К достоинствам использования динамических библиотек относят
	0.  (-) удобство развертывания
	1.  (-) высокая производительность
	2.  (-) удобство сборки
	3.  (+) возможность использования разных языков программирования
244. [Динамические библиотеки] К недостаткам использования динамических библиотек относят
	0.  (-) неэкономное использование памяти
	1.  (-) медленный процесс сборки
	2.  (-) невозможность использования разных языков программирования
	3.  (+) потери производительности
245. [Лексический анализ] Cтруктурная единица языка, которая состоит из элементарных символов языка это
	0.  (+) лексема
	1.  (-) токен
	2.  (-) строка
	3.  (-) слово
246. [Лексический анализ] В ЯП Pascal else является
	0.  (+) ключевым словом
	1.  (-) идентификатором
	2.  (-) знаком арифметической операции
	3.  (-) разделителем
247. [Лексический анализ] Если измениться кодировка исходной программы, то это повлияет
	0.  (+) только на лексический анализатор
	1.  (-) на лексический и синтаксический анализаторы
	2.  (-) на синтаксический и семантический анализаторы
	3.  (-) на генератор объектного кода
248. [Лексический анализ] К типам лексем ЯП не относится
	0.  (+) альфа-лексемы
	1.  (-) разделители
	2.  (-) ключевые слова
	3.  (-) идентификаторы
249. [Лексический анализ] Лексический анализ
	0.  (+) является одним из первых этапов трансляции
	1.  (-) на этапе трансляции идет до обработки препроцессором
	2.  (-) при трансляции следует сразу же после синтаксического анализа
	3.  (-) при трансляции следует сразу же после семантического анализа
250. [Лексический анализ] Лексический анализ на лету – это
	0.  (+) функция тестового редактора в составе программирования
	1.  (-) первый этап лексического анализа
	2.  (-) последний этап лексического анализа
	3.  (-) функция текстового редактора заключающаяся в поиске и выделении лексем непосредственно после создания программы разработчиком
251. [Лексический анализ] Причиной, по которой в состав практически всех компиляторов включают лексический анализ, является
	0.  (+) все перечисленные варианты
	1.  (-) возможность снизить трудоемкость разработки программ за счет обработки текста исходной программы, параллельно с его подготовкой пользователем
	2.  (-) необходимость отделять синтаксический анализатор, сложный по конструкции, от работы непосредственно с текстом исходной программы
	3.  (-) необходимость сокращать объем информации, обрабатываемой на этапе синтаксического разбора
252. [Лексический анализ] Распознавание и выделение лексем из входной последовательности символов производится
	0.  (+) Лексическим анализатором
	1.  (-) Компилятором
	2.  (-) Интерпретатором
	3.  (-) Вторичным загрузчиком
253. [Лексический анализ] Таблица лексем содержит
	0.  (+) весь текст исходной программы, обработанный лексическим анализатором
	1.  (-) только ключевые слова исходной программы обработанный лексическим анализатором
	2.  (-) текст исходной программы обработанный лексическим анализатором
	3.  (-) таблицу идентификаторов
254. [Лексический анализ] Теоретической моделью, используемой при построении лексического анализатора, является
	0.  (+) Конечный автомат
	1.  (-) Машина Тьюринга
	2.  (-) Клеточный автомат
	3.  (-) Линейный автомат
255. [Лексический анализ] Функции, выполняемые лексическим анализатором и тип лексем, которые он должен выделять определяются
	0.  (+) разработчиком компилятора
	1.  (-) формой Бэкуса-Наура
	2.  (-) второым классом грамматик Хомского
	3.  (-) только перечнем библиотечных функций
256. [Лексический анализ] В ЯП Pascal begin является
	0.  (+) ключевым словом
	1.  (-) идентификатором
	2.  (-) знаком арифметической операции
	3.  (-) разделителем
257. [Лексический анализ] Определение границ лексем — это
	0.  (+) выделение тех строк в общем потоке входных символов, для которых надо выполнять распознавание
	1.  (-) разбиение потока входных символов на блоки фиксированного размера
	2.  (-) задание соответствие между некоторой частью входных символов и смысловым значением соответствующей лексемы
	3.  (-) разбиение байтового потока на блоки фиксированного размера
258. [Лексический анализ] Причинами, по которым в состав практически всех компиляторов включают лексический анализ являются
	0.  (+) все перечисленные варианты
	1.  (-) необходимость сокращать объем информации, обрабатываемой на этапе синтаксического разбора
	2.  (-) необходимость отделять синтаксический анализатор, сложный по конструкции, от работы непосредственно с текстом исходной программы
	3.  (-) возможность снизить трудоемкость разработки программ за счет обработки текста исходной программы, параллельно с его подготовкой пользователем
259. [Лексический анализ] Какая из таблиц заполняется на этапе лексического анализа
	0.  (+) Таблица идентификаторов
	1.  (-) Таблица ключевых слов
	2.  (-) Таблица разделителей
	3.  (-) Таблица ссылок
260. [Лексический анализ] Выберите таблицы, используемые на этапе лексического анализа
	0.  (-) Таблица ссылок, таблица констант, таблица классификаторов
	1.  (+) Таблица идентификаторов, таблица ключевых слов, таблица разделителей, таблица констант
	2.  (-) Таблица идентификаторов, таблица ключевых слов, таблица перекрестных ссылок, таблица прямых ссылок
	3.  (-) Таблица констант, таблица переменных, таблица ссылочных значений, таблица мутабельных структур
